# 算法

## 算法概论

- **算法，问题之解法也**
- 广义而言，写的每个程序都是一个算法，其中的每个函数也都是一个算法
- 下面的一些文章我们将探讨极具复用价值的70余个STL算法，包括排序（sorting）、查找（searching）、排列组合（permutation）、以及用于数据移动、赋值、删除、比较、组合、运算等的算法
- 特定的算法往往搭配特定的数据结构，例如二叉搜索树（binary search tree）和红黑树（RB-tree）、哈希表（hash table）等

### 算法分析与算法复杂度

- **算法分析：**分析算法所耗费的资源，包括空间和时间
- 算法的复杂度，可以作为我们衡量算法的效率的标准
- 一般而言，算法的**执行时间和其所要处理的数据量有关，两者之间存在某种函数关系**，可能是一次（线型，linear）、二次（quadratic）、三次（cubic）或对数（logarithm）关系
  - **但数据量很小时，**其中的每一项都可能对结果带来相当程度的影响
  - **但是数据量很大时，**只有最高次的项目才具有主导地位

> ### 算法复杂度表示方法
>
> - **大O记法（Big-Oh）：**
>
> 如果有任何正值常数c和$N_0$，使得当$N\geq N_0$时，$T(N)\leq cF(N)$，那么我们便可将T(N)的复杂度表示为$O(F(N))$。
>
> - 其他方法**还有Big-Omega、Big-Theta、Little-Oh等**
> - 其中大O记法使用最广泛，但是不适用来标记小数据量的情况

> ### 下面是三个复杂度各异的问题
>
> - **①最小元素问题：**求取array中的最小元素
>
>   该问题的解法必须两两元素对比，因此N个元素需要N次对比，所以数据量与执行时间呈线性关系。**该问题的复杂度为O(N)**
>
> - **②最短距离问题：**求取X-Y平面上的N个点中，距离最近的两个点
>
>   该问题所需要计算的元素对共有N/(N-Z)/2!，所以大数据量和执行时间呈二次关系。**该问题的复杂度为$O(N^2)$**
>
> - **③三点共线问题：**决定X-Y平面上的N个点中，是否有任何三点共线
>
>   该问题要计算的元素对共有N(N-1)(N-2)/3!，所以大数据量和执行时间呈三次关系。**该问题的复杂度为$O(N^3)$**
>
> ### 下面三个问题出现一种新的复杂度形式
>
> - **④需要多少bits才能表现出N个连续整数**
>
>   该问题中，B个bits可表现出$2^B$个不同的整数，因此想要表现出N个连续整数，需要满足方程式$2^B\geq N$，即$B\geq logN$
>
> - **⑤从X=1开始，每次将X扩充两倍，需要多少次扩充才能使X>=N**
>
>   该问题称为“持续加倍问题”，必须满足方程式$2^k\geq N$，此问题与上面的问题4相同，因此解答相同
>
> - ⑥从X=N开始，每次将X缩减一半，需要多少次缩减才能使X<=1
>
>   该问题成为“持续减半问题”，与上面的问题相同，只不过方向相反
>
> 如果一个算法，花费固定时间（常数时间，O(1)）将问题的规模降低某个固定比例（通常是1/2），基于上述问题⑥的解答，我们便说此算法的复杂度是$O(logN)$
>
> 注意：问题规模的降低比例如何，并不会带来影响，因为他会反应在对数的底上，而底对于BIg-Oh标记法是没有影响的（任何的算法书上应该都会有证明）

### STL算法总览

- 下图显示了STL算法（以及一些非标准的SGI STL算法）的名称、用途、文件分布等等
- 凡是不在STL标准之中的，都以*标记

![STL算法总览1](./img/STL算法总览1.png)

![STL算法总览2](./img/STL算法总览2.png)

![STL算法总览3](./img/STL算法总览3.png)

![STL算法总览4](./img/STL算法总览4.png)

### 质变算法、非质变算法

> ### 质变算法（mutating algorithms）——会改变操作对象的值
>
> - 所有的STL算法都作用在由迭代器[first,last)所标示出来的区间上
> - 质变算法在运算过程中**会更改区间内的元素内容**。但是不一定改变传入的对象，可能是复制一份再改变
> - 例如**拷贝（copy）、交换（swap）、替换（replace）、填写（file）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）**等算法
> - 所以如果你把**这些算法运用在一个常数区间上是错误的。**例如：
>
> ```c++
> #include <vector>
> #include <algorithm>
> using namespace std;
>  
>  
> int main()
> {
>     int ia[] = { 22,30,30,17,33,40,19,23,22,12,20 };
>     vector<int> iv(ia, ia + sizeof(ia) / sizeof(int));
>  
>     vector<int>::const_iterator citer1 = iv.begin();
>     vector<int>::const_iterator citer2 = iv.end();
>     
>     sort(citer1, citer2);
>     
>     return 0;
> }
> ```

> ### 非质变算法（nonmutating algorithms）——不会改变操作对象的值
>
> - 所有的STL算法都作用在由迭代器[first,last)所标示出来的区间上
> - 非质变算法在运算过程中**不会更改区间内的元素内容**
> - 例如**查找（find）、匹配（search）、计数（count）、遍历（for_each）、比较（equal,mismatch）、寻找极值（max,min）**等算法
> - 例如你在for_each算法身上**应用一个会改变元素内容的仿函数，那么也可以让非质变算法变为质变算法**
>
> ```c++
> #include <vector>
> #include <algorithm>
> using namespace std;
>  
> template<class T>
> struct plus2
> {
> 	void operator()(T& x)const
> 	{
> 		x += 2;
> 	}
> };
>  
> int main()
> {
> 	int ia[] = { 22,30,30,17,33,40,19,23,22,12,20 };
> 	vector<int> iv(ia, ia + sizeof(ia) / sizeof(int));
>  
> 	for_each(iv.begin(), iv.end(), plus2<int>()); //正确
> 	return 0;
> }
> ```

### STL算法的一些性质

> ### 算法操作的是迭代器的区间
>
> - 算法的前**两个参数都是一对迭代器，**通常为分别为first和last
> - STL习惯**采用前闭后开区间。**例如[first,last)区间表示包含first至last（但是不含last）。当first==last时，是一个空区间
> - 这个[first,last)区间**必要条件是，必须能够从first遍历到last**。编译器本身无法强求这一点，但是如果你的程序不支持，那么就会造成不可预期的后果
> - 在迭代器的文章中我们介绍了**，迭代器可以分为5类：**
>
> ![迭代器的分类与从属关系](./img/迭代器的分类与从属关系.png)
>
> * **最低程度迭代器类型：**
>   * 每种算法都需要其最低程序的迭代器类型。例如find()最低要求需要一个Input Iterator，这是其最低的要求
>   * 但是其也可以接受更高类型的迭代器，例如Forward Iterator，Bidirectiona Iterator或RandomAccess Iterator（因为这3个迭代器也都是Input Iterator的一种）
>   * 但是你绝不能将Output Interator传递给find()

> ### 有些算法不止一个版本
>
> - **STL有些算法不只支持一个版本。**
>
>   这类算法的某个版本采用缺省运算行为，其他版本提供额外的参数，接受外界传入一个仿函数
>
>   - 例如unique()缺省下使用equality操作符来比较两个相邻元素，但是用户也可以自己定义equality操作符然后传递给unique()
>
> - **有些算法将两个不同版本的函数不同命名，**附从的那个以_if结尾
>
>   - 例如find()的另一个版本为fond_if()
>   - 例如replace()的的另一个版本为replace_if()

> ### 质变算法通常提供两个版本
>
> - **质变算法通常提供两个版本：**
>   - 一个是in-place（就地进行）版本，就地改变其操作对象
>   - 另一个是copy（另地进行）版本，将操作对象的内容复制一份副本，然后在副本上修改并返回该副本。copy版本的总是以_copy的结尾
> - 例如replace()是in-place版本的，但是replace_copy()是copy版本的
> - 并不是所有质变算法都有copy版，例如sort()就没有两个版本，如果我们希望以这类“无copy”版本的质变算法实施于某一段区间元素的副本身上，我们必须自行制作并传递那一份副本。

> ### 头文件
>
> - **所有的数值算法**等都实现于<stl_numeric.h>中（这是个内部头文件）。应用层使用应该包含<numeric>
> - **其他STL算法**都实现于<stl_algo.h>和<stl_algobase.h>中（也是内部头文件）。应用层使用应该包含<algorithm>

## 算法的泛化过程

- **算法的泛化过程就是将算法独立于其所处理的数据结构之外，**不受数据结构的约束。使一个算法适用于所有的数据结构（不论传入算的是vector、list还是deque等）
- 关键在于，只要把操作对象的类型加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化，整个算法就可以在一个抽象层面上工作了。**整个过程称为算法的泛型化，简称泛化**

> ### 演示案例（一步一步的进行泛化）
>
> **第一步：**
>
> 现在我们需要设计一个算法，在数组中查找某一个特定的值，那么我们可能会设计下面的函数：
>
> - 该算法在数组中查找元素，返回一个指针。如果找到就返回这个位置的地址，如果没有找到就返回数组最后一个元素的下一个位置
> - **这种算法的缺点：**这种算法暴露了容器太多的细节，也太过依赖于容器的类型
>
> ```c++
> int* find(int* arrayHead, int arraySize, int value)
> {
>     int i=0;
>     for (; i < arraySize; ++i)
>     {
>         if (arrayHead[i] == value)
>             break;
>     }
> 	
>     return &(arrayHead[i]);
> }
>  
> int main()
> {
>     const int arraySize = 7;
>     int ia[arraySize] = { 0,1,2,3,4,5,6 };
>     int *end = ia + arraySize;
>  
>     int* ip = find(ia, arraySize, 4);
>     if (ip == end)
>         std::cout << "4 not found" << std::endl;
>     else
>         std::cout << "4 found." << *ip << std::endl;
>     return 0;
> }
> ```
>
> **第二步：**为了让算法更抽象些，应该让算法接受两个指针作为参数，表示出操作一个区间
>
> - 这个函数在“前闭后开”区间[begin,end)内查找元素，返回值与第一步中的函数相同
> - 但是这个算法只能适用于int型的数组，不能适用于其他类型的容器
>
> ```c++
> int* find(int* begin, int* end, int value)
> {
>     while ((begin != end) && (*begin != value))
>         ++begin;
>  
>     return begin;
> }
>  
> int main()
> {
>     const int arraySize = 7;
>     int ia[arraySize] = { 0,1,2,3,4,5,6 };
>     int *end = ia + arraySize;
>  
>     int* ip = find(ia, end, 4);
>     if (ip == end)
>         std::cout << "4 not found" << std::endl;
>     else
>         std::cout << "4 found." << *ip << std::endl;
>     return 0;
> }
> ```
>
> **第三步：**我们可以将第二步的算法进行加工，声明为一个模板，使其适用于所有的类型
>
> - 注意：参数3改了，改为了pass-by-reference-to-const
> - 这个模板可以适用于任何容器
>
> ```c++
> template<typename T>
> T* find(T* begin, T* end, const T& value)
> {
>     while ((begin != end) && (*begin != value))
>         ++begin;
>  
>     return begin;
> }
> ```
>
> **第四步：**上面的模板只能使用指针作为区间传入函数，但是STL设计的迭代器就是一种智能指针，迭代器是一种类似指针的对象。因此我们可以将指针改为迭代器然后作为算法的参数和返回值
>
> - **这就是算法最终的泛化版本，**在STL中的算法都是这样实现的
>
> ```c++
> template<class Iterator,typename T>
> Iterator* find(Iterator* begin, Iterator* end, const T& value)
> {
>     while ((begin != end) && (*begin != value))
>         ++begin;
>  
>     return begin;
> }
> ```
>

## 数值算法

- 这些算法STL内部实现于<stl_numeric.h>中，**应用层实现应该包含头文件<numeric>**

### accumulate

- **功能：**默认情况下，用来计算init和[first，last)区间内所有元素的总和
- init一定要提供。这么做的原因是当[first，last)为空区间时仍能获得一个明确的值
- 版本②接受一个仿函数
- **返回值：**返回计算出的和
- 版本②中的二元操作符不必满足交换律和结合律

> ### 版本①
>
> ```c++
> template <class _InputIterator, class _Tp>
> _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   for ( ; __first != __last; ++__first) //将每个元素值累加到初值init身上
>     __init = __init + *__first;
>   return __init;
> }
> ```
>
> ### 版本②
>
> ```c++
> template <class _InputIterator, class _Tp, class _BinaryOperation>
> _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
>                _BinaryOperation __binary_op)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   for ( ; __first != __last; ++__first)
>     __init = __binary_op(__init, *__first);// 对每一个元素执行二元操作
>   return __init;
> }
> ```

> ### 演示案例
>
> ```c++
> #include <iostream>
> #include <iterator> //ostream_iterator
> #include <numeric>
> #include <vector>
> using namespace std;
>  
> int main()
> {
>     int ia[5] = { 1,2,3,4,5 };
>     vector<int> iv(ia, ia + 5);
>  
>     //15。计算过程：0+1+2+3+4+5
>     std::cout << accumulate(iv.begin(), iv.end(), 0) << std::endl;
>  
>     //-15。计算过程：0-1-2-3-4-5
>     std::cout << accumulate(iv.begin(), iv.end(), 0, minus<int>()) << std::endl;
>  
>     return 0;
> }
> ```

### adjacent_difference

- **功能：**默认情况下，用来计算[first，last)区间内每两个元素之间的差，并将差保存在参数3所指向的result中

  注意对应关系：result[0]=*first、result[1]=*(first+1)-*(first)、result[1]=*(first+2)-*(first+1)...以此类推

- 版本②接受一个仿函数

- **该函数与partial_sum互为逆运算。**例如对区间1、2、3、4、5执行adjacent_difference获得结果为1、1、1、1、1，再对此结果执行partial_sum，便可以得到原始区间值1、2、3、4、5

- **返回值：**返回参数3

> ### 版本①
>
> ```c++
> template <class _InputIterator, class _OutputIterator, class _Tp>
> _OutputIterator 
> __adjacent_difference(_InputIterator __first, _InputIterator __last,
>                       _OutputIterator __result, _Tp*)
> {
>   _Tp __value = *__first;
>   while (++__first != __last) { //走过整个区间
>     _Tp __tmp = *__first;
>     *++__result = __tmp - __value; // 将相邻两元素的差额（后-前），赋值给目的端
>     __value = __tmp;
>   }
>   return ++__result;
> }
> 
> template <class _InputIterator, class _OutputIterator>
> _OutputIterator
> adjacent_difference(_InputIterator __first,
>                     _InputIterator __last, _OutputIterator __result)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   __STL_REQUIRES(_OutputIterator, _OutputIterator);
>   if (__first == __last) return __result;
>   *__result = *__first;//首先记录第一个元素
>   return __adjacent_difference(__first, __last, __result,
>                                __VALUE_TYPE(__first));
> }
> ```
>
> ### 版本②
>
> ```c++
> template <class _InputIterator, class _OutputIterator, class _Tp, 
>           class _BinaryOperation>
> _OutputIterator
> __adjacent_difference(_InputIterator __first, _InputIterator __last, 
>                       _OutputIterator __result, _Tp*,
>                       _BinaryOperation __binary_op) {
>   _Tp __value = *__first;
>   while (++__first != __last) {
>     _Tp __tmp = *__first;
>     *++__result = __binary_op(__tmp, __value);
>     __value = __tmp;
>   }
>   return ++__result;
> }
> 
> template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
> _OutputIterator 
> adjacent_difference(_InputIterator __first, _InputIterator __last,
>                     _OutputIterator __result, _BinaryOperation __binary_op)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   __STL_REQUIRES(_OutputIterator, _OutputIterator);
>   if (__first == __last) return __result;
>   *__result = *__first;
>   return __adjacent_difference(__first, __last, __result,
>                                __VALUE_TYPE(__first),
>                                __binary_op);
> }
> ```

> ### 演示案例
>
> ```c++
> #include <iostream>
> #include <iterator> //ostream_iterator
> #include <numeric>
> #include <vector>
> using namespace std;
>  
> int main()
> {
>     int ia[5] = { 1,2,3,4,5 };
>     vector<int> iv(ia, ia + 5);
>  
>     //将这个迭代器绑定到cout上，作为下面的输出
>     ostream_iterator<int> oiter(std::cout, " ");
>  
>     //1 1 1 1 1
>     adjacent_difference(iv.begin(), iv.end(), oiter);
>     std::cout << std::endl;
>  
>     //1 3 5 7 9
>     adjacent_difference(iv.begin(), iv.end(), oiter, plus<int>());
>     std::cout << std::endl;
>  
>     return 0;
> }
> ```

### inner_product

- **功能：**默认情况下，以init参数为初始值，将[first1，last1)区间内的元素与以first2区间开始的元素进行内积（乘）操作，然后将结果返回
- **返回值：**返回内积的总和
- 版本②提供两个仿函数参数，第一个用于表示两个区间之间对应元素操作之后是加、还是减等。第二个用于代表函数返回的是[first1，last1)区间与first2区间的各个元素之间是加还是减等

> ### 版本①
>
> ```c++
> template <class _InputIterator1, class _InputIterator2, class _Tp>
> _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
>                   _InputIterator2 __first2, _Tp __init)
> {
>   __STL_REQUIRES(_InputIterator2, _InputIterator);
>   __STL_REQUIRES(_InputIterator2, _InputIterator);
>   for ( ; __first1 != __last1; ++__first1, ++__first2)
>     __init = __init + (*__first1 * *__first2);
>   return __init;
> }
> ```
>
> ### 版本②
>
> ```c++
> template <class _InputIterator1, class _InputIterator2, class _Tp,
>           class _BinaryOperation1, class _BinaryOperation2>
> _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
>                   _InputIterator2 __first2, _Tp __init, 
>                   _BinaryOperation1 __binary_op1,
>                   _BinaryOperation2 __binary_op2)
> {
>   __STL_REQUIRES(_InputIterator2, _InputIterator);
>   __STL_REQUIRES(_InputIterator2, _InputIterator);
>   for ( ; __first1 != __last1; ++__first1, ++__first2)
>     __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
>   return __init;
> }
> ```

> ### 演示案例
>
> ```c++
> #include <iostream>
> #include <iterator> //ostream_iterator
> #include <numeric>
> #include <vector>
> using namespace std;
>  
> int main()
> {
>     int ia[5] = { 1,2,3,4,5 };
>     vector<int> iv(ia, ia + 5);
>  
>     //65。计算过程：10 + 1*1 + 2*2 + 3*3 + 4*4 + 5*5
>     std::cout << inner_product(iv.begin(), iv.end(), iv.begin(), 10) << std::endl;
>  
>     //-65。计算过程：10 - 1+1 - 2+2 - 3+3 - 4+4 - 5+5
>     std::cout << inner_product(iv.begin(), iv.end(), iv.begin(), 10,
>         minus<int>(), plus<int>()) << std::endl;
>     return 0;
> }
> ```

### partial_sum

- **功能：**默认情况下，用来计算局部和。在[first，last)区间上，迭代器每移动一次，就将其以及前面所有的元素的值进行一个和，然后保存到存储参数3中

  形式是result[0]=*first、result[1]=*(first)+*(first+1)、result[1]=*(first)+*(first+1)+*(first+2)...以此类推

- **返回值：**参数3

- 备注：运算的时候是从前向后运算，而不是从后向前运算

- 版本②提供一个仿函数，用来指定是每回运算是加还是减等

> ### 版本①
>
> ```c++
> template <class _InputIterator, class _OutputIterator, class _Tp>
> _OutputIterator 
> __partial_sum(_InputIterator __first, _InputIterator __last,
>               _OutputIterator __result, _Tp*)
> {
>   _Tp __value = *__first;
>   while (++__first != __last) {
>     __value = __value + *__first;
>     *++__result = __value;
>   }
>   return ++__result;
> }
> 
> template <class _InputIterator, class _OutputIterator>
> _OutputIterator 
> partial_sum(_InputIterator __first, _InputIterator __last,
>             _OutputIterator __result)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   __STL_REQUIRES(_OutputIterator, _OutputIterator);
>   if (__first == __last) return __result;
>   *__result = *__first;
>   return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first));
> }
> ```
>
> ### 版本②
>
> ```c++
> template <class _InputIterator, class _OutputIterator, class _Tp,
>           class _BinaryOperation>
> _OutputIterator 
> __partial_sum(_InputIterator __first, _InputIterator __last, 
>               _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)
> {
>   _Tp __value = *__first;
>   while (++__first != __last) {
>     __value = __binary_op(__value, *__first);
>     *++__result = __value;
>   }
>   return ++__result;
> }
> 
> template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
> _OutputIterator 
> partial_sum(_InputIterator __first, _InputIterator __last,
>             _OutputIterator __result, _BinaryOperation __binary_op)
> {
>   __STL_REQUIRES(_InputIterator, _InputIterator);
>   __STL_REQUIRES(_OutputIterator, _OutputIterator);
>   if (__first == __last) return __result;
>   *__result = *__first;
>   return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first), 
>                        __binary_op);
> }
> ```

> ### 演示案例
>
> ```c++
> #include <iostream>
> #include <iterator> //ostream_iterator
> #include <numeric>
> #include <vector>
> using namespace std;
>  
> int main()
> {
>     int ia[5] = { 1,2,3,4,5 };
>     vector<int> iv(ia, ia + 5);
>  
>     //将这个迭代器绑定到cout上，作为下面的输出
>     ostream_iterator<int> oiter(std::cout, " ");
>  
>     //1 3 6 10 15
>     partial_sum(iv.begin(), iv.end(), oiter);
>     std::cout << std::endl;
>     
>     //1 -1 -4 -8 -13
>     partial_sum(iv.begin(), iv.end(), oiter, minus<int>());
>     std::cout << std::endl;
>  
>     return 0;
> }
> ```

### power

- **功能：**返回某数的n幂次方。这里的n幂次是指自己对自己进行某种运算达n次
- 运算类型可由外界指定。例如指定乘法，那就是乘幂

> ### 版本①
>
> ```c++
> // 乘幂
> template <class _Tp, class _Integer>
> inline _Tp __power(_Tp __x, _Integer __n)
> {
>   return __power(__x, __n, multiplies<_Tp>());
> }
> ```
>
> ### 版本②
>
> ```c++
> // 幂次方。如果指定为乘法运算，则当n>=0时返回x^n
> template <class _Tp, class _Integer, class _MonoidOperation>
> _Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr)
> {
>   if (__n == 0)
>     return identity_element(__opr);
>   else {
>     while ((__n & 1) == 0) {
>       __n >>= 1;
>       __x = __opr(__x, __x);
>     }
> 
>     _Tp __result = __x;
>     __n >>= 1;
>     while (__n != 0) {
>       __x = __opr(__x, __x);
>       if ((__n & 1) != 0)
>         __result = __opr(__result, __x);
>       __n >>= 1;
>     }
>     return __result;
>   }
> }
> ```

### itoa

- **功能：**把区间[first,last)内的元素依次改变为：*(first)=value、*(first+1)=value+1、*(first+2)=value+2...、*(first+(last-first-1))=value+(last-first-1)。用来设定某个区间的内容，使其内的每一个元素从指定的value值开始，呈现递增状态。
- **无返回值**
- 属于质变算法

> ```c++
> template <class _ForwardIter, class _Tp>
> void 
> iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)
> {
>   __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
>   __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);
>   while (__first != __last)
>     *__first++ = __value++;
> }
> ```

>### 演示案例
>
>```c++
>#include <iostream>
>#include <iterator> //ostream_iterator
>#include <numeric>
>#include <vector>
>using namespace std;
> 
>int main()
>{
>    int ia[5] = { 1,2,3,4,5 };
>    vector<int> iv(ia, ia + 5);
> 
>    int n = 3;
>    iota(iv.begin(), iv.end(), n);
> 
>    //3 4 5 6 7
>    for (int i = 0; i < iv.size(); ++i)
>        std::cout << iv[i] << " ";
>    std::cout << std::endl;
>    return 0;
>}
>```

## 基本算法

- STL标准没有区分基本算法或复杂算法，但是SGI却把一些常用的**基本算法定义在<stl_algobase.h>中**，**其他算法定义于<stl_algo.h>中**
- 应用层使用的**头文件<algorithm>包含<stl_algobase.h>与<stl_algo.h>**

### equal

如果两个序列在[first,last)区间内相等，equal()返回true。如果第二序列的元素比较多，多出来的元素不予考虑。

> ```c++
> template <class _InputIter1, class _InputIter2>
> inline bool equal(_InputIter1 __first1, _InputIter1 __last1,
>                   _InputIter2 __first2) {
>   __STL_REQUIRES(_InputIter1, _InputIterator);
>   __STL_REQUIRES(_InputIter2, _InputIterator);
>   __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
>                  _EqualityComparable);
>   __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,
>                  _EqualityComparable);
>   for ( ; __first1 != __last1; ++__first1, ++__first2)
>     if (*__first1 != *__first2)
>       return false;
>   return true;
> }
> 
> template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
> inline bool equal(_InputIter1 __first1, _InputIter1 __last1,
>                   _InputIter2 __first2, _BinaryPredicate __binary_pred) {
>   __STL_REQUIRES(_InputIter1, _InputIterator);
>   __STL_REQUIRES(_InputIter2, _InputIterator);
>   for ( ; __first1 != __last1; ++__first1, ++__first2)
>     if (!__binary_pred(*__first1, *__first2))
>       return false;
>   return true;
> }
> ```

### fill

将[first,last)内的所有元素改填新值

> ```c++
> template <class _ForwardIter, class _Tp>
> void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value) {
>   __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
>   for ( ; __first != __last; ++__first)
>     *__first = __value;
> }
> ```

### fill_n

将[first,last)内的前n个元素改填新值，返回的迭代器指向被填入的最后一个元素的下一位置。

> ```c++
> template <class _OutputIter, class _Size, class _Tp>
> _OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value) {
>   __STL_REQUIRES(_OutputIter, _OutputIterator);
>   for ( ; __n > 0; --__n, ++__first)
>     *__first = __value;
>   return __first;
> }
> ```

由于每次迭代进行的是assignment操作，是一种覆写(overwrite)操作，所以一旦操作区间超越了容器大小，就会造成不可预期的结果。解决办法之一是，利用inserter()产生一个具有插入(insert)而非覆写(overwrite)能力的迭代器。inserter()可产生一个用来修饰迭代器的配接器(iterator adapter)。

### iter_swap

将两个ForwardIterrators所指的对象对调

> ```c++
> template <class _ForwardIter1, class _ForwardIter2, class _Tp>
> inline void __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*) {
>   _Tp __tmp = *__a;
>   *__a = *__b;
>   *__b = __tmp;
> }
> 
> template <class _ForwardIter1, class _ForwardIter2>
> inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b) {
>   __STL_REQUIRES(_ForwardIter1, _Mutable_ForwardIterator);
>   __STL_REQUIRES(_ForwardIter2, _Mutable_ForwardIterator);
>   __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter1>::value_type,
>                     typename iterator_traits<_ForwardIter2>::value_type);
>   __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter2>::value_type,
>                     typename iterator_traits<_ForwardIter1>::value_type);
>   __iter_swap(__a, __b, __VALUE_TYPE(__a));
> }
> ```

iter_swap()是“迭代器之value type”派上用场的一个好例子。是的，该函数必须知道迭代器的value type，才能够据此声明一个对象，用来暂时存放迭代器所指对象。