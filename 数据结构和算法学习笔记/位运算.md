# 位运算

程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。

由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。

## 位运算符

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0                  |
| >>   | 右移 | 各二进制位全部右移若干位，对无符号数，高位补0。有符号位，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

XOR-异或

> 异或：相同为0，不同为1。也可用“不进位加法”来理解。

异或操作的一些特点：

```
x ^ 0 = x
x ^ 1s = ~x //  1s = ~0 全部二进制都是1
x ^ (~x) = 1s
x ^ x = 0 // interesting and important!
a ^ b = c => a ^ c = b, b ^ c = a // swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
```

## 编程常用的位运算操作

* X & 1 == 1 OR == 0  => 判断奇偶性(X % 2 == 1)
* X = X & (X -1)  =>  清0最低位的1
* X & -X => 得到最低位的1

### 更为复杂的位运算操作

1.  将 `x` 最右边的 `n` 位清0： `x & (~0 << n)`
2.  获取 `x` 的第 `n` 位值(0或者1)：`(x >> n) & 1`
3.  获取 `x` 的第 `n` 位的幂值： `x & (1 << (n - 1))`
4.  仅将第 `n` 位置为 `1`：`x | (1 << n)`
5.  仅将第 `n` 位置为 `0`：`x & (~(1 << n))`
6.  将 `x` 最高位至第 `n` 位(含)清0：`x & ((1 << n) - 1)`
7.  将第 `n` 位至第0位(含)清0： `x & (~((1 << (n + 1)) - 1))`

## C++ \_\_builtin_系列函数

在用到位运算的时候用这些函数会更加快捷



__builtin_ffs(x); // 返回 x 的最后一位 1 是从后向前第几位

```c++
__builtin_ffs(0100) == 3;
```

__builtin_clz(x); // 返回 x 的二进制下前导的 0 的个数(一共有32位)

```c++
__builtin_clz(0100) == 29;
```

__builtin_ctz(x); // 返回 x的二进制下末尾的 0 的个数

```c++
__builtin_ctz(0100) == 2;
```

__builtin_popcount(x); // 返回 x 的二进制下 1 的个数

```c++
__builtin_popcount(0100) == 1;
```

__builtin_parity(x); // 返回 x 的二进制下 1 的个数的奇偶性(奇数为1，偶数为0)

```c++
__builtin_parity(0100) == 1;
```

