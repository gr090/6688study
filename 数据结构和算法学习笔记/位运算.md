# 位运算

程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。

由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。

## 位运算符

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0                  |
| >>   | 右移 | 各二进制位全部右移若干位，对无符号数，高位补0。有符号位，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

XOR-异或

> 异或：相同为0，不同为1。也可用“不进位加法”来理解。

异或操作的一些特点：

```
x ^ 0 = x
x ^ 1s = ~x //  1s = ~0 全部二进制都是1
x ^ (~x) = 1s
x ^ x = 0 // interesting and important!
a ^ b = c => a ^ c = b, b ^ c = a // swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
```

## 编程常用的位运算操作

* X & 1 == 1 OR == 0  => 判断奇偶性(X % 2 == 1)
* X = X & (X -1)  =>  清0最低位的1
* X & -X => 得到最低位的1

### 更为复杂的位运算操作

1.  将 `x` 最右边的 `n` 位清0： `x & (~0 << n)`
2.  获取 `x` 的第 `n` 位值(0或者1)：`(x >> n) & 1`
3.  获取 `x` 的第 `n` 位的幂值： `x & (1 << (n - 1))`
4.  仅将第 `n` 位置为 `1`：`x | (1 << n)`
5.  仅将第 `n` 位置为 `0`：`x & (~(1 << n))`
6.  将 `x` 最高位至第 `n` 位(含)清0：`x & ((1 << n) - 1)`
7.  将第 `n` 位至第0位(含)清0： `x & (~((1 << (n + 1)) - 1))`

## C++ \_\_builtin_系列函数

在用到位运算的时候用这些函数会更加快捷



__builtin_ffs(x); // 返回 x 的最后一位 1 是从后向前第几位

```c++
__builtin_ffs(0100) == 3;
```

__builtin_clz(x); // 返回 x 的二进制下前导的 0 的个数(一共有32位)

```c++
__builtin_clz(0100) == 29;
```

__builtin_ctz(x); // 返回 x的二进制下末尾的 0 的个数

```c++
__builtin_ctz(0100) == 2;
```

__builtin_popcount(x); // 返回 x 的二进制下 1 的个数

```c++
__builtin_popcount(0100) == 1;
```

__builtin_parity(x); // 返回 x 的二进制下 1 的个数的奇偶性(奇数为1，偶数为0)

```c++
__builtin_parity(0100) == 1;
```



## 在 O(1) 的时间复杂度内，求一个以二进制表示的整数末尾有多少个 0

* 常规解法：

```c++
while ((n & (1 << count)) == 0) {
	count += 1;
}
```

时间复杂度$O(log_2N)$

* 位运算解法

对于正整数x，它在计算机中的存储是它本身的二进制表示，而-x在计算机中的存储则是将它取反之后再加上 1，即-x+1。一个数取反之后，它的二进制表示中，最低位的那个 1 会变成 0，从它往低全都变成了 1，而加 1 之后，最低位 1 的那个 bit 还会变成 1，从它往低又全都变成了 0。也就是说，x和-x在计算机中的表示，以x的二进制表示中最低位的 1 为界，从它开始，低位全都一样，高位全都互反，所以我们可以通过 x & (-x)，就能取出最低位 1。这样可以通过取对数$log_2(n \& (-n))$ 或查表求解。

时间复杂度O(1)

* 位扫描解法：

```c++
unsigned int v; // find the number of trailing zeros in 32-bit v
int r; // result goes here
static const int MultiplyDeBruijnBitPosition[32] =
{
0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};
r = MultiplyDeBruijnBitPosition[((uint32_t)((v & -v) * 0x077CB531U)) >> 27];
```

利用这一段代码，我们就可以在真 O(1) 的时间复杂度下，求出一个整数的二进制表示中末尾有多少个 0。

> **De Bruijn序列**
>
> 一个整数是以 32bit 的长度存储在计算机中的，如果不算符号位，它的最高 5 位，一共有多少种情况呢？自然是 32 种情况，从00000到11111。我们将常量0x077CB531展开成二进制表示，就是00000111011111001011010100110001。我们将它看作是一个循环的圆，然后从中依次取出相邻的 5 个 bit，如下图：
>
> ![](D:/gr/6688study/数据结构和算法学习笔记/img/位循环表示.png)
>
> 这个时候，我们就发现了一个问题，我们取出的这些数刚好是从00000到11111的所有数，既没有重复，也没有遗漏。这样的序列被称作De Bruijn序列。它的定义是，B(n, k)为 n 个元素组成的一个循环序列，在这个循环序列中所有长度为 k，且由 n 个元素构成的序列都在它的子序列中，且仅出现一次，那0x077CB531这个常量的二进制表示就是B(2, 5)的一个序列。

上面的代码我们就可以这样来解释：我们去看这个常量乘上了一个 2^x^ 之后，它的前 5bit 是什么。由于这个常量中，每一个长度为 5 的窗口互相之间都是不一样的，或者说，每一个长度为 5 的窗口都只对应了一个x，因此，它们就可以用一个长度为 32 的数组存储起来了。

这样一来，当我们将整数n最低位的 1 取出与常量相乘，再查看它前 5 位的时候，直接查表就可以找到那个对应的x，即n的二进制表示中末尾 0 的位置。

比如说整数 104，经过计算就是104 & -104 = 8，也就是1000，因为 8=2^3，所以需要把它左移 3 位：

000001110111110010110101001100001  -->  001110111110010110101001100001000

我们看到它的前五位是00111=7，查表可以看到MultiplyDeBruijnBitPosition[7]=3，结果是正确的。那如果左移超过了 27 位呢？其实也没有关系，这个常量的前 5 位都是 0，左移也是用 0 来补低位，所以刚好形成了循环。
