# 动态规划

![](./img/动态规划.webp)

动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 

一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个 子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 

算法步骤
1、最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 

2、子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。 动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是 在表格中简单地查看一下结果，从而获得较高的效率。



动态规划两步曲：

* DP状态的定义

* DP状态转移方程

动态规划（Dynamic Programming）比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。

动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 **「最优子结构」** ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。

**「滚动数组思想」**是一种常见的动态规划优化方法，当我们定义的状态在动态规划的转移方程中只和某几个状态相关的时候，就可以考虑这种优化方法，目的是给空间复杂度「降维」。



## 动态规划理论

什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？

### 一个模型三个特征

“一个模型”指的是动态规划适合解决的问题的模型，即**分阶段决策最优解模型**。我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

“三个特征”指的是**最优子结构**、**无后效性**和**重复子问题**。

* **1.最优子结构**

  最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

* **2.无后效性**

  无后效性有两层含义：

  第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。

  第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。

  无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

* **3.重复子问题**

  不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

两种动态规划的解题思路，分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，**回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码**。状态转移方程法的大致思路可以概括为，**找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码**。

### 两种动态规划解题思路总结

解决动态规划问题，一般有状态转移表法和状态转移方程法两种思路。

#### 1. 状态转移表法

一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，画出对应的递归树。从递归树中，可以很容易看出来是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。

找到重复子问题之后，接下来有两种处理思路，第一种是直接用**回溯加“备忘录”**的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，**状态转移表法**。

先画出一个状态表。状态表一般都是二维的。其中，每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。

尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。

#### 2. 状态转移方程法

状态转移方程法有点类似递归的解题思路，需要分析某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下有**递归加“备忘录”和迭代递推**两种代码实现方法。

### 贪心/分治/回溯和动态规划的区别和联系

贪心、回溯、动态规划都可以抽象成**多阶段决策最优解模型**，而分治单独尽管大部分也是最优解问题却都不能抽象成多阶段决策模型。

回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。

能用动态规划解决的问题，需要满足最优子结构、无后效性和重复子问题三个特征。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。

解决复杂算法问题的小技巧：

**先单纯考虑“人脑”会如何去解决这个问题**，把抽象问题具象化，实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。

再就是要**多练**，做多了题目之后，自然就会有感觉，看到问题，立马就能想到能否用动态规划解决，然后直接就可以寻找最优子结构，写出动态规划方程，然后将状态转移方程翻译成代码。

## 从贪心算法到动态规划

首先，贪心算法是根据当前阶段得到局部最优解，然后再看下一个阶段，逐个求解。这样导致的问题就是，我们可能永远无法得到真正的最优解：整体最优解。

为了解决这个问题，我们在贪心算法中加入了回溯的过程。如果无法求解的时候，就会返回，然后重新尝试当前阶段的“局部次优方案”，重新计算这种情况下的解。这样一来，我们至少保证了所有问题都能求得一个解。

但是如果遇到一些局部最优解前提条件不一定满足全局最优解的情况，这种方法也不一定能让我们找到整体最优解，因为贪心算法里我们找到一个解就结束了，如果约束不足，那么返回可能不一定是整体最优解。

为了解决贪心算法的问题，真正求得整体最优解，我们就必须得到问题解的所有可能组合。这个时候我们就要利用递归来解决问题。

递归就是自顶向下求得满足问题条件的所有组合，并计算这些组合的解，最后从这些组合的解中取出最优解，这样暴力计算出来的结果必定是整体最优解。

但是这样就又出现了效率问题，暴力递归在计算量巨大的情况下，时间复杂度实在太高了，几乎会呈现指数爆炸形式。那么我们就得考虑是否有些问题可以进行剪枝优化。

我提出了一些剪枝优化的方法，重点介绍的就是利用重叠子问题进行优化。在递归求解过程中我们会把一个大问题分解成多个子问题，那些在求解计算分支中可能被反复求解的子问题就是所谓的重叠子问题。

如果这些重叠子问题无后效性，那么我们就可以利用缓存的方法，在求得每个子问题的解之后将求解结果存入缓存数组中。如果在后续的计算分支中遇到相同的子问题，就直接从备忘录中取出我们已经计算过的结果。

这样一来，我们就不需要浪费时间重复求解已经求解的问题，在这种情况下可以将时间复杂度约束在多项式级别。

但是递归求解最后还是会有性能损耗问题，因此这时正式引入了动态规划。在经历了这些讨论与探索后，你现在应该能够理解动态规划与贪心、回溯、递归的关系了。



带备忘录的递归解法从传统意义上说已经是动态规划思想的范畴了，但它使用的是自顶向下的处理方式来解题，它离我们日常看到的动态规划还有差距。

这个差距不仅仅体现在代码的形式上，更重要的是它仍然还不够好：递归本身的性质导致了算法执行时额外的存储开销。

为此，我们正式引入自底向上的一种处理方式，并用迭代代替了递归，实现了较为简洁的硬币找零动归解法。在多项式级别的算法时间复杂度内，我们用最快的速度得到了我们想要的结果。

另外，动态规划的关键是状态转移方程，为了写出它，我们需要按照套路找出以下项目：

1. 初始化状态：由于动态规划是根据已经计算好的子问题推广到更大问题上去的，因此我们需要一个“原点”作为计算的开端；
2. 状态：找出子问题与原问题之间会发生变化的变量，这个变量就是状态转移方程中的参数；
3. 决策：改变状态，让状态不断逼近初始化状态的操作。这个决策，就是状态转移方程状态转移的方向。

最后，我们要将以上信息组装起来，一般来说就可以得到动态规划的状态转移方程了。

## 0-1背包问题

对于一组不同重量、不可分割的物品，选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

> 0-1背包问题回溯的解决方法：
>
> 穷举搜索所有可能的装法，然后找出满足条件的最大值。指数级别的复杂度。
>
> ```java
> 
> // 回溯算法实现。
> private int maxW = Integer.MIN_VALUE; // 结果放到maxW中
> private int[] weight = {2，2，4，6，3};  // 物品重量
> private int n = 5; // 物品个数
> private int w = 9; // 背包承受的最大重量
> public void f(int i, int cw) { // 调用f(0, 0)
>   if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
>     if (cw > maxW) maxW = cw;
>     return;
>   }
>   f(i+1, cw); // 选择不装第i个物品
>   if (cw + weight[i] <= w) {
>     f(i+1,cw + weight[i]); // 选择装第i个物品
>   }
> }
> ```
>
> 可以使用备忘录记录已经计算好的f(i,cw)，当再次计算到重复的f(i,cw)的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算
>
> ```java
> 
> private int maxW = Integer.MIN_VALUE; // 结果放到maxW中
> private int[] weight = {2，2，4，6，3};  // 物品重量
> private int n = 5; // 物品个数
> private int w = 9; // 背包承受的最大重量
> private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值false
> public void f(int i, int cw) { // 调用f(0, 0)
>   if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
>     if (cw > maxW) maxW = cw;
>     return;
>   }
>   if (mem[i][cw]) return; // 重复状态
>   mem[i][cw] = true; // 记录(i, cw)这个状态
>   f(i+1, cw); // 选择不装第i个物品
>   if (cw + weight[i] <= w) {
>     f(i+1,cw + weight[i]); // 选择装第i个物品
>   }
> }
> ```
>
> 

动态规划的解决思路：

将整个求解过程分为n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，即达到多种不同的状态，对应到递归树中，就是有很多不同的节点。

把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。通过合并每一层重复的状态，保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），从而避免每层状态个数的指数级增长。

用一个二维数组 states\[n][w+1]，来记录每层可以达到的不同状态。

第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。可用states\[0][0]=true和states\[0][2]=true来表示这两种状态。

第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。用states\[1][0]=true，states\[1][2]=true，states\[1][4]=true来表示这三种状态。

考察完所有的物品后，整个 states 状态数组就都计算好了。

在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。

```java
//weight: 物品重量，n: 物品个数，w: 背包可承载重量
public int knapsack(int[] weight, int n, int w) {
  boolean[][] states = new boolean[n][w+1]; // 默认值 false
  states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
  states[0][weight[0]] = true;
  for (int i = 1; i < n; ++i) { // 动态规划状态转移
    for (int j = 0; j <= w; ++j) {// 不把第 i 个物品放入背包
      if (states[i-1][j] == true) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j <= w-weight[i]; ++j) {// 把第 i 个物品放入背包
      if (states[i-1][j]==true) states[i][j+weight[i]] = true;
    }
  }
  for (int i = w; i >= 0; --i) { // 输出结果
    if (states[n-1][i] == true) return i;
  }
  return 0;
}
```

这就是一种用动态规划解决问题的思路：把问题分解为多个阶段，每个阶段对应一个决策，然后记录每一个阶段可达的状态集合（去掉重复的），通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。

用回溯算法解决这个问题的时间复杂度是 O(2^n^)指数级的。而动态规划解决方案的时间复杂度是 O(n*w)，n 表示物品个数，w 表示背包可以承载的总重量。



上述代码实现额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。但实际上只需要一个大小为 w+1 的一维数组就可以解决这个问题，动态规划状态转移的过程，都可以基于这个一维数组来操作：

```java
public static int knapsack2(int[] items, int n, int w) {
  boolean[] states = new boolean[w+1]; // 默认值 false
  states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
  states[items[0]] = true;
  for (int i = 1; i < n; ++i) { // 动态规划
    for (int j = w-items[i]; j >= 0; --j) {// 把第 i 个物品放入背包
      if (states[j]==true) states[j+items[i]] = true;
    }
  }
  for (int i = w; i >= 0; --i) { // 输出结果
    if (states[i] == true) return i;
  }
  return 0;
}
```

注意：内层for循环j必须从大到小来处理，否则会出现 for 循环重复计算的问题。

### 0-1背包问题升级版

上面的背包问题只涉及背包重量和物品重量。现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？

> 回溯解决方法：
>
> ```java
> 
> private int maxV = Integer.MIN_VALUE; // 结果放到maxV中
> private int[] items = {2，2，4，6，3};  // 物品的重量
> private int[] value = {3，4，8，9，6}; // 物品的价值
> private int n = 5; // 物品个数
> private int w = 9; // 背包承受的最大重量
> public void f(int i, int cw, int cv) { // 调用f(0, 0, 0)
>   if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
>     if (cv > maxV) maxV = cv;
>     return;
>   }
>   f(i+1, cw, cv); // 选择不装第i个物品
>   if (cw + weight[i] <= w) {
>     f(i+1,cw+weight[i], cv+value[i]); // 选择装第i个物品
>   }
> }
> ```
>
> 在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。
>
> 在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。也就是说，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。如果用回溯算法，这个问题就没法再用“备忘录”解决了。

动态规划解决：

把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。

用一个二维数组 states\[n][w+1]，来记录每层可以达到的不同状态，数组存储当前状态对应的最大总价值。

把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。

```java
public static int knapsack3(int[] weight, int[] value, int n, int w) {
  int[][] states = new int[n][w+1];
  for (int i = 0; i < n; ++i) { // 初始化 states
    for (int j = 0; j < w+1; ++j) {
      states[i][j] = -1;
    }
  }
  states[0][0] = 0;
  states[0][weight[0]] = value[0];
  for (int i = 1; i < n; ++i) { // 动态规划，状态转移
    for (int j = 0; j <= w; ++j) { // 不选择第 i 个物品
      if (states[i-1][j] >= 0) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j <= w-weight[i]; ++j) { // 选择第 i 个物品
      if (states[i-1][j] >= 0) {
        int v = states[i-1][j] + value[i];
        if (v > states[i][j+weight[i]]) {
          states[i][j+weight[i]] = v;
        }
      }
    }
  }
  // 找出最大值
  int maxvalue = -1;
  for (int j = 0; j <= w; ++j) {
    if (states[n-1][j] > maxvalue) maxvalue = states[n-1][j];
  }
  return maxvalue;
}
```

上述代码时间复杂度和空间复杂度都是 O(n*w)。空间复杂度可以优化为O(w)。

### 背包问题模板代码

```c++
int main(){
    // 各个物品的重量
    vector<int> weight = {2, 3, 4, 7};
    // 对应的价值
    vector<int> value = {1, 3, 5, 9};

    // 背包最大能放下多重的物品
    int bagWeight = 10;

    // 二维数组状态定义：dp[i][j]表示从前 i 个物品中选择不超过 j 重量的物品的最大价值
    // 初始化：第一列都是0，第一行也都是0
    // dp[0][j] = 0, dp[i][0] = 0
    // 1.因为在背包容量为 0 的情况下，无法放入任何东西，价值为 0
    // 2.因为在前 0 个物品中，表示没有物品可以选，背包无法放入任何东西，价值为 0
    auto dp = vector<vector<int>>(weight.size() + 1, vector<int>(bagWeight + 1));

    for(int i = 1; i <= weight.size(); i++){
        // 遍历背包容量
        for(int j = 1; j <= bagWeight; j++){
            // 背包容量小于当前物品的容量，即背包容量已经不足以放第 i 个物品了
            if(j < weight[i-1]){
                // 最大价值就是去考虑当前背包容量情况下，从前 i-1 个物品中选择出最大价值
                dp[i][j] = dp[i-1][j];
            }
            // 背包容量足够放第 i 个物品，那么可以选择放或者不放
            // 1.选择放，那么最大价值是第 i-1 个物品扣除第 i 个物品的重量的情况下的最大价值，再加上第 i 个物品的价值
            // 2.选择不放，那么就是从前 i-1 个物品中选择出的最大价值
            // 两者进行比较取较大的
            else{
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1]);
            }
        }
    }
    return dp[weight.size()][bagWeight];    
}
```

使用滚动数组优化：

```c++
int main(){
    // 各个物品的重量
    vector<int> weight = {2, 3, 4, 7};
    // 对应的价值
    vector<int> value = {1, 3, 5, 9};

    // 背包最大能放下多重的物品
    int bagWeight = 10;

    // 二维数组状态定义：dp[i][j]表示从前 i 个物品中选择不超过 j 重量的物品的最大价值
    // 滚动数组优化为一维数组
    auto dp = vector<int>(bagWeight + 1);

    for(int i = 1; i <= weight.size(); i++){
        // 遍历背包容量
        for(int j = bagWeight; j >= 1; j--){
            // 背包容量足够放第 i 个物品，那么可以选择放或者不放
            if(j >= weight[i-1]){
                dp[j] = max(dp[j], dp[j-weight[i-1]] + value[i-1]);
            }
        }
    }
    return dp[bagWeight];
}
```



## 双11购物的凑单问题

淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。假设你的购物车中有 n 个（n>100）想买的商品，希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），如何编程解决这个问题？

思路：

动态规划，购物车中有 n 个商品，针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。用一个二维数组 states\[n][x]，来记录每次决策之后所有可达的状态。

对于这个问题来说，要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际的问题而言，如果要购买的物品的总价格超过 200 太多，比如 1000，那这个羊毛“薅”得就没有太大意义了。所以，可以限定 x 值为 1001。

求出大于等于 200 的总价格中的最小的，还要找出这个最小总价格对应都要购买哪些商品。可以利用 states 数组，倒推出这个被选择的商品序列。

```java
// items 商品价格，n 商品个数, w 表示满减条件，比如 200
public static void double11advance(int[] items, int n, int w) {
  boolean[][] states = new boolean[n][3*w+1];// 超过 3 倍就没有薅羊毛的价值了
  states[0][0] = true;  // 第一行的数据要特殊处理
  states[0][items[0]] = true;
  for (int i = 1; i < n; ++i) { // 动态规划
    for (int j = 0; j <= 3*w; ++j) {// 不购买第 i 个商品
      if (states[i-1][j] == true) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j <= 3*w-items[i]; ++j) {// 购买第 i 个商品
      if (states[i-1][j]==true) states[i][j+items[i]] = true;
    }
  }
 
  int j;
  for (j = w; j < 3*w+1; ++j) { 
    if (states[n-1][j] == true) break; // 输出结果大于等于 w 的最小值
  }
  if (j == 3*w+1) return; // 没有可行解
  for (int i = n-1; i >= 1; --i) { // i 表示二维数组中的行，j 表示列
    if(j-items[i] >= 0 && states[i-1][j-items[i]] == true) {
      System.out.print(items[i] + " "); // 购买这个商品
      j = j - items[i];
    } // else 没有购买这个商品，j 不变。
  }
  if (j != 0) System.out.print(items[0]);
}
```

利用 states 数组倒推选择购买了哪些商品的方法：

状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states\[i-1][j] 或者 states\[i-1][j-value[i]] 是否是 true。

如果  states\[i-1][j] 可达，就说明我们没有选择购买第 i 个商品，如果 states\[i-1][j-value[i]] 可达，那就说明选择了购买第 i 个商品。从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。

## 搜索引擎中的拼写纠错功能

利用 Trie 树，可以实现搜索引擎的关键词提示功能。实际上在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。

### 如何量化两个字符串的相似程度

量化两个字符串之间的相似程度，有一个非常著名的量化方法是编辑距离（Edit Distance）。

**编辑距离**指将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。

根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有**莱文斯坦距离**（Levenshtein distance）和**最长公共子串长度**（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。

莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。

下图中两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。

![](./img/编辑距离.webp)

**如何计算莱文斯坦距离？**

这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合**多阶段决策最优解模型**。

1.回溯算法解决

回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：

* 可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；
* 可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；
* 可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];
* 可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；
* 可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。

```java

private char[] a = "mitcmu".toCharArray();
private char[] b = "mtacnu".toCharArray();
private int n = 6;
private int m = 6;
private int minDist = Integer.MAX_VALUE; // 存储结果
// 调用方式 lwstBT(0, 0, 0);
public lwstBT(int i, int j, int edist) {
  if (i == n || j == m) {
    if (i < n) edist += (n-i);
    if (j < m) edist += (m - j);
    if (edist < minDist) minDist = edist;
    return;
  }
  if (a[i] == b[j]) { // 两个字符匹配
    lwstBT(i+1, j+1, edist);
  } else { // 两个字符不匹配
    lwstBT(i + 1, j, edist + 1); // 删除a[i]或者b[j]前添加一个字符
    lwstBT(i, j + 1, edist + 1); // 删除b[j]或者a[i]前添加一个字符
    lwstBT(i + 1, j + 1, edist + 1); // 将a[i]和b[j]替换为相同字符
  }
}
```

根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。

在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。

2.动态规划解决

定义状态(i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。

状态转移方程：

```
如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)

如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))

其中，min表示求三数中的最小值。     
```

代码实现：

```java
public int lwstDP(char[] a, int n, char[] b, int m) {
  int[][] minDist = new int[n][m];
  for (int j = 0; j < m; ++j) { // 初始化第0行:a[0..0]与b[0..j]的编辑距离
    if (a[0] == b[j]) minDist[0][j] = j;
    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;
    else minDist[0][j] = 1;
  }
  for (int i = 0; i < n; ++i) { // 初始化第0列:a[0..i]与b[0..0]的编辑距离
    if (a[i] == b[0]) minDist[i][0] = i;
    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;
    else minDist[i][0] = 1;
  }
  for (int i = 1; i < n; ++i) { // 按行填表
    for (int j = 1; j < m; ++j) {
      if (a[i] == b[j]) minDist[i][j] = min(
          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);
      else minDist[i][j] = min(
          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);
    }
  }
  return minDist[n-1][m-1];
}

private int min(int x, int y, int z) {
  int minv = Integer.MAX_VALUE;
  if (x < minv) minv = x;
  if (y < minv) minv = y;
  if (z < minv) minv = z;
  return minv;
}
```

**如何编程计算最长公共字串长度**

最长公共子串作为编辑距离中的一种，只允许增加、删除字符两种编辑操作。

这个问题也可以用动态规划解决，现在定义状态，然后写状态转移方程。

每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i] 和 b[0…j] 的最长公共子串长度。那 (i, j) 这个状态都是由哪些状态转移过来的呢？

回溯的处理思路从 a[0] 和 b[0] 开始，依次考察两个字符串中的字符是否匹配。

- 如果 a[i] 与 b[j] 互相匹配，将最大公共子串长度加一，并且继续考察 a[i+1] 和 b[j+1]。
- 如果 a[i] 与 b[j] 不匹配，最长公共子串长度不变，然后有两个不同的决策路线：
  1. 删除 a[i]，或者在 b[j] 前面加上一个字符 a[i]，然后继续考察 a[i+1] 和 b[j]；
  2. 删除 b[j]，或者在 a[i] 前面加上一个字符 b[j]，然后继续考察 a[i] 和 b[j+1]。

反过来看，如果要求 a[0…i] 和 b[0…j] 的最长公共长度 max_lcs(i, j)，只有可能通过下面三个状态转移过来：

- (i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1] 和 b[0…j-1] 的最长公共子串长度；
- (i-1, j, max_lcs)，其中 max_lcs 表示 a[0…i-1] 和 b[0…j] 的最长公共子串长度；
- (i, j-1, max_lcs)，其中 max_lcs 表示 a[0…i] 和 b[0…j-1] 的最长公共子串长度。

状态转移方程：

```
如果：a[i]==b[j]，那么：max_lcs(i, j) 就等于：
max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；
 
如果：a[i]!=b[j]，那么：max_lcs(i, j) 就等于：
max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；
 
其中 max 表示求三数中的最大值。
```

java代码：

```java
public int lcs(char[] a, int n, char[] b, int m) {
  int[][] maxlcs = new int[n][m];
  for (int j = 0; j < m; ++j) {// 初始化第 0 行：a[0..0] 与 b[0..j] 的 maxlcs
    if (a[0] == b[j]) maxlcs[0][j] = 1;
    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];
    else maxlcs[0][j] = 0;
  }
  for (int i = 0; i < n; ++i) {// 初始化第 0 列：a[0..i] 与 b[0..0] 的 maxlcs
    if (a[i] == b[0]) maxlcs[i][0] = 1;
    else if (i != 0) maxlcs[i][0] = maxlcs[i-1][0];
    else maxlcs[i][0] = 0;
  }
  for (int i = 1; i < n; ++i) { // 填表
    for (int j = 1; j < m; ++j) {
      if (a[i] == b[j]) maxlcs[i][j] = max(
          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);
      else maxlcs[i][j] = max(
          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);
    }
  }
  return maxlcs[n-1][m-1];
}
 
private int max(int x, int y, int z) {
  int maxv = Integer.MIN_VALUE;
  if (x > maxv) maxv = x;
  if (y > maxv) maxv = y;
  if (z > maxv) maxv = z;
  return maxv;
}
```

### 搜索引擎中的拼写纠错功能实现与优化思路

拼写纠错最基本的原理是当用户在搜索框内，输入一个拼写错误的单词时，就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。

针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。

- 取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。
- 用多种编辑距离计算方法，分别求编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。
- 通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最长被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。
- 更加高级一点的做法是引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。

纠错性能的两种分治的优化思路：

- 如果纠错功能的 TPS 不高，可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。
- 如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。

## 硬币找零问题

假设有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果要支付 w 元，求最少需要多少个硬币。比如，有 1 元、3 元、5 元3 种不同的硬币，要支付 9 元最少需要 3 个硬币（3 个 3 元的硬币）。

动态规划分析思路：

求支付w元最少需要多少个硬币，可以分解为求支付w-v1,w-v2,，……，w-vn元需要硬币数的最小值+1，

用memo[w+1]作为状态数组来记录支付x元，最少所需要的硬币数。

初始化支付0元需要0个硬币，即memo[0]=0.

然后以此状态为基础，依次计算出支付1元，支付2元，...，直到支付w元，最少需要的硬币数。

```python
def coins_dp(values: List[int], w: int) -> int:
    # memo[i]表示w为i的时候，最少需要的硬币数
    memo = [0] * (w + 1)
    # 初始化支付0元需要0个硬币
    memo[0] = 0
    # 可选硬币列表从小到大排序
    values.sort()
    for i in range(1, w + 1):
        min_num = 99999  # 假设最大金额为100000
        # 假设values的值为n1,n2,n3,...
        # 故memo[i]=min(memo[i-n1], memo[i-n2], ...) + 1
        for n in values:
            if i - n < 0: break
            if min_num > memo[i - n]:
                min_num = memo[i - n]
        memo[i] = min_num + 1
    return memo[-1]
```



c++实现：

```c++
int GetMinCounts(int k, const std::vector<int>& values) {
    int memo[k + 1]; // 创建备忘录
    memo[0] = 0; // 初始化状态
    for (int i = 1; i < k + 1; i++) { memo[i] = k + 1; }
    
    for (int i = 1; i < k + 1; i++) {
        for (auto coin : values) {
            if (i - coin < 0) { continue; }
            memo[i] = min(memo[i], memo[i - coin] + 1); // 作出决策
        }
    }

    return memo[k] == k + 1 ? -1 : memo[k];
}

int GetMinCountsDPSolAdvance() {
    std::vector<int> values = { 3, 5 }; // 硬币面值
    int total = 11; // 总值

    return GetMinCounts(total, values); // 输出答案
}
```

