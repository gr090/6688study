# 红黑树

## 平衡二叉查找树

二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。但二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于$log_2n$的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到O(n)。要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。

平衡二叉树的严格定义是任意一个节点的左右子树的高度相差不能大于 1。

完全二叉树、满二叉树都是平衡二叉树，非完全二叉树也有可能是平衡二叉树。

最先被发明的平衡二叉查找树是[AVL 树](https://zh.wikipedia.org/wiki/AVL树)，它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。

但是很多平衡二叉查找树并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

所以，**平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。**

所以，只要树的高度不比 $log_2n$ 大很多（树的高度仍然是对数量级的），就仍然可以认为这是一个合格的平衡二叉查找树。

### 各种平衡二叉树的对比

绝大部分情况下Treap、Splay Tree操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但AVL 树为了维持这种高度的平衡，每次插入、删除都要做调整比较复杂、耗时。对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高。

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用更倾向于这种性能稳定的平衡二叉查找树。

### 动态数据结构优劣势对比

动态数据结构支持动态地数据插入、删除、查找操作

散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。

跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。

红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。

## 红黑树

平衡二叉查找树有Splay Tree（伸展树）、Treap（树堆）等，但用的最多的平衡二叉查找树基本都是红黑树。有时候甚至默认平衡二叉查找树就是红黑树。

红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

![](./img/红黑树/红黑树定义.webp)

### 红黑树的“近似平衡”

平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，**“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重**。

二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 $log_2n$，红黑树是否近似平衡就看红黑树的高度是否比较稳定地趋近$log_2n$ 。

红黑树的高度计算：

先计算单纯包含黑色节点的红黑树的高度，红色节点删除之后，失去父节点的节点拿自己的祖父节点（父节点的父节点）作为父节点。之前的二叉树就变成了四叉树。

红黑树中，从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

完全二叉树的高度近似$log_2n$，四叉“黑树”的高度低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过$log_2n$。

有一个红色节点就至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过$log_2n$，所以加入红色节点之后，最长路径不会超过$2log_2n$，也就是说，红黑树的高度近似 $2log_2n$。

所以，红黑树的高度能比较稳定地趋近$log_2n$， 是近似平衡的。

### 实现红黑树的基本思想

红黑树的平衡过程跟魔方复原非常神似，大致过程就是：**遇到什么样的节点排布，就对应怎么去调整**。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。

一棵合格的红黑树需要满足的要求：

1. 根节点是黑色的；
2. 叶子节点都是黑色的空节点（NIL），不存储数据；
3. 红色节点被黑色节点隔开的，不得出现两个连续的红色节点；
4. 每个节点到达其可达叶子节点的所有路径包含黑色节点的个数要相等。

在插入删除节点的过程中，第3、4后面两点要求可能会被破坏，“平衡调整”就是把被破坏的第3、4点恢复过来。

### 平衡操作中两个非常重要的操作

**左旋（rotate left）全称叫围绕某个节点的左旋**，

**右旋（rotate right）全称叫围绕某个节点的右旋**。

![](./img/红黑树/红黑树左旋右旋操作.webp)

### 插入操作的平衡调整

**红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**。

插入操作的平衡调整，有这样两种特殊情况：

- 如果插入节点的父节点是黑色的，无需任何调整。
- 如果插入的节点是根节点，那就直接把它改成黑色就可以了。

其他情况都需要进行调整，调整的过程包含两种基础的操作：**左右旋转**和**改变颜色**。

红黑树的平衡调整是一个迭代的过程。正在被处理的节点叫**关注节点**，关注节点会随着不停地迭代处理，而不断发生变化，最开始的关注节点就是新插入的节点。

新节点插入之后，如果红黑树的平衡被打破一般会有下面三种情况。只需要根据每种情况采取对应的策略去调整，然后不停的迭代，就可以让红黑树继续符合定义从而保持平衡。

下面把父节点的兄弟节点称为**叔叔节点**，父节点的父节点称为**祖父节点**。

#### **CASE 1：关注节点 a的叔叔节点 d 是红色**

- 将关注节点 a 的父节点 b、叔叔节点 d 都设置成黑色；
- 将关注节点 a 的祖父节点 c 设置成红色；
- 关注节点变成 a 的祖父节点 c；
- 跳到 CASE 2 或者 CASE 3。

![](./img/红黑树/红黑树插入操作Case1.webp)

#### CASE 2：关注节点 a的叔叔节点 d 是黑色，而且节点 a是其父节点的右子节点：

- 关注节点变成节点 a 的父节点 b；
- 围绕新的关注节点b 左旋；
- 跳到 CASE 3。

如果关注节点 的叔叔节点是黑色而且是右子节点，就将关注节点设置为关注节点的父节点并左旋，最后跳到 CASE 3。

![](./img/红黑树/红黑树插入操作Case2.webp)

#### **CASE 3：关注节点a的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点**：

- 围绕关注节点 a 的祖父节点 c 右旋；
- 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。
- 调整结束。

如果关注节点 的叔叔节点是黑色而且是左子节点，就围绕关注节点的祖父节点右旋，最后将关注节点的父节点 与关注节点的兄弟节点 颜色互换。

![](./img/红黑树/红黑树插入操作Case3.webp)

### 删除操作的平衡调整

删除操作的平衡调整分为两步，

针对删除节点初步调整：调整到每个节点到达其可达叶子节点的所有路径包含黑色节点的个数要相等

针对关注节点二次调整：调整到不存在相邻的两个红色节点

#### 1. 初步调整

经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

图示说明：如果一个节点既可以是红色也可以是黑色，用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，用左上角的一个小黑点来表示额外的黑色。

##### CASE 1：要删除的节点 a只有一个子节点 b

节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。

节点b替换到节点 a 的位置并把节点 a 删除，然后将节点b的颜色设置为黑色。

![](./img/红黑树/红黑树删除操作_第1步_Case1.webp)

##### CASE 2：要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c

节点 a 的后继节点是右子节点 c表示右子节点 c没有左子树。

- 将后继节点 c 替换到节点 a 的位置并把节点 a 删除；
- 节点 c 设置为跟节点 a 相同的颜色；
- 如果节点 c 是黑色，就给节点 c 的右子节点 d 多加一个黑色，节点 d 就成了“红 - 黑”或者“黑 - 黑”；
- 关注节点设置为节点 d，准备进行二次调整。

![](./img/红黑树/红黑树删除操作_第1步_Case2.webp)

##### CASE 3：要删除的节点 a有两个非空子节点，并且节点 a 的后继节点不是右子节点

节点 a 的后继节点不是右子节点表示右子节点存在左子树。

- 将节点 a 的数据修改为后继节点 d的数据，然后按照CASE 1删除后继节点 d ；
- 如果节点a 是黑色，给节点 a 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；
- 关注节点设置为节点 c，准备进行二次调整。

![](./img/红黑树/红黑树删除操作_第1步_Case3.webp)

#### 2.二次调整

经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，需要再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。

##### CASE 1：关注节点 a的兄弟节点 c 是红色

- 围绕关注节点 a 的父节点 b 左旋；
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
- 关注节点不变，继续从四种情况中选择适合的规则来调整。

![](./img/红黑树/红黑树删除操作_第2步_Case1.webp)

##### CASE 2：关注节点 a的兄弟节点 c 是黑色，并且节点 c 的左右子节点 d、e 都是黑色

- 将关注节点 a 的兄弟节点 c设置为红色；
- 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；
- 关注节点从 a 变成其父节点 b；
- 继续从四种情况中选择符合的规则来调整。

![](./img/红黑树/红黑树删除操作_第2步_Case2.webp)

##### CASE 3：关注节点a的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色

- 围绕关注节点 a 的兄弟节点 c 右旋；
- 节点 c 和节点 d 交换颜色；
- 关注节点不变，跳到 CASE 4，继续调整。

![](./img/红黑树/红黑树删除操作_第2步_Case3.webp)

##### CASE 4：关注节点 a 的兄弟节点 c 是黑色，并且兄弟节点c 的右子节点是红色的

- 围绕关注节点 a 的父节点 b 左旋；
- 将关注节点 a 的兄弟节点 c 设置为跟关注节点 a 的父节点 b 相同的颜色；
- 将关注节点 a 的父节点 b 和叔叔节点 e 设置为黑色；
- 去掉关注节点 a 的一个黑色，节点 a 就变成了单纯的红色或者黑色；
- 调整结束。

![](./img/红黑树/红黑树删除操作_第2步_Case4.webp)

### 为什么红黑树要求叶子节点是黑色的空节点？

是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为上面说到那几种情况。

假设红黑树不要求“叶子节点必须是黑色的空节点”，当插入节点的父节点也是红色的时候，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。这个时候，新插入的节点没有叔叔节点，三种情况下的平衡调整规则就都不适用的。

![](./img/红黑树/红黑树要求叶子节点是黑色空节点1.webp)

但如果把黑色的空节点都给它加上，就可以满足 CASE 2 ：

![](./img/红黑树/红黑树要求叶子节点是黑色空节点2.webp)

CASE 2 可以改为“关注节点 a的叔叔节点 d 是黑色或者叔叔节点 d 不存在， a是其父节点的右子节点”，但没有原来的规则简洁。

给红黑树添加黑色的空的叶子节点，并不会太浪费存储空间呢。因为在具体实现的时候，只需共用一个黑色的、空的叶子节点就行了。

![](./img/红黑树/红黑树要求叶子节点是黑色空节点3.webp)

### 如何比较轻松学会红黑树

第一点，**把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性**。只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。

第二点，**找准关注节点，不要搞丢、搞错关注节点**。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。

第三点，**插入操作的平衡调整比较简单，但是删除操作就比较复杂**。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。



## 2-3树

要更好地理解红黑树的设计，首先你要理解红黑树的由来——红黑树本质上是对“2-3 树”的一种实现。

2-3 树，也是一种平衡查找树的实现，思想很简单，为了让树能更好地平衡自己，我们除了普通的 2 节点之外，还引入了一种 3 节点，这让我们在平衡树高度的时候增大了很大的灵活性。看一个典型的2-3树例子：

![](./img/2-3树/2-3树01.webp)

在 2-3 树中，2 节点，和普通二叉树的节点其实没有什么太大的区别，有一个键和两条链，分别链向左子树和右边子树。而 3 节点，则在 2 节点的基础上增加了一个键，构成了一个有两个键和三条链的结构。下图是 3 节点的示意图，左链链向了小于 a 的节点，右链链向了大于 b 的节点，中间的区域则是 a 和 b 之间的节点。

![](./img/2-3树/2-3树02.webp)

在 2-3 树中搜索的过程和二叉树并没有太多的区别，只是遇到 3 节点的时候，多判断一次是否介于 a、b 之间即可。

在插入过程中，当我们查找到了某个叶子结点发现并不存在该键时，如果遇到了 2 节点，非常好办，直接加个键将该节点升级为 3 节点即可。比较麻烦的是遇到了 3 节点，因为我们已经不能再在该节点中直接多加一个键创造一个 4 节点了，怎么办呢？其实办法也不难想，我们把当前的 4 节点多出的键向上转移。看图理解，比如要对下图中的 2-3 树插入 26 节点，那首先会沿着根节点一路查询到“19 24”子结点，发现该节点为一个 3 节点。那么我们首先将 26 放入该子节点，使之成为一个 4 节点，然后将 4 节点的中间键也就是 24，提升到上一层，将其父节点替换成一个包含 24 的 3 节点。

![](./img/2-3树/2-3树插入节点.webp)

如果原父节点也是一个 3 节点的话，我们就递归进行同样的操作直至根节点。最后，如果根节点也是一个 3 节点，我们就将根节点的中键提升到第一层，然后左右链分别链向原来根节点的左键和右键。以下图为例，b 键就被独立地提升为新的根节点，左右节点指向 a 和 c，而原 4 节点的中间两个链也分别成为 a 的右链和 c 的左链。

![](./img/2-3树/2-3树插入节点02.webp)

这样的操作可以保证整个 2-3 Tree 是一个真正意义上的平衡树。但是，因为它的实现引入了两种异构的节点，导致代码写起来相当复杂，并没有被广泛使用。而红黑树，**正是采用标准的二叉查找树节点附着上额外的颜色信息来表示 2-3 树的实现，每一个红色节点都和它的父亲节点一起，构成了一个 3 节点的模拟，这就是红黑树设计的本质**。

所以，我们再把红黑树的定义拿出来，红黑树是一个满足下述几个约束且所有节点要么为红色要么为黑色的二分有序查找树：

* 根节点为黑色

* 相邻的节点不能同时为红色
* 每个节点从自身到各个能到达的叶子结点的所有路径中的黑色节点数量相等
* 红节点只能作为左子节点存在（这是左偏红黑树特有的要求，我们以左偏红黑树为例讲解）

所有这些约束，都是为了保证每一颗红黑树和 2-3 Tree 是一一对应的，相信你看下面这颗“展平”的红黑树就能理解我在说什么了。

![](./img/2-3树/2-3树与红黑树.webp)

一个 3 节点有两个键、三条链，那我们完全可以把一个以红节点为左子节点的黑节点和子节点一起看成一个 3 节点。在下图中，上下两个图其实就可以认为是等价的。

![](./img/2-3树/2-3树与红黑树02.webp)

我们再来看红黑树的 3 个普遍约束，你会发现很好理解：

1. 因为红色节点只是 3 节点的一部分，那对应到红黑树上，显然不会出现两个连续的红色结点；
2. 2-3 树上，每个节点到叶子节点的数量一定是一样的，且每个节点对应到红黑树上一定包含且只包含一个黑色节点，所以红黑树每个节点到叶子结点路径中的黑色节点数量也必然是一样的。

唯一不一样的就是“根节点为黑色”。事实上，如果只是为了让红黑树保持平衡，我们完全可以抛弃这条规则。因为在 2-3 树中，我们也完全是可以用 3 节点作为根节点的。

对应到红黑树中，当根节点为红色，插入新节点后很可能为了使根节点到每条路径上的黑色节点数量相等，进行变色和旋转操作，最终根节点还是会变成黑色；既然如此，我们何不直接约束根节点必须调整成黑色，方便进行插入操作呢。

这样，我们就可以将每一个红黑树都映射成一个 2-3 树，也因此就获得了 2-3 树高效的平衡插入的能力，并保留了二叉树查找的简洁性。之后在理解红黑树的时候，如果你能时刻展平成 2-3 树看待，一定会觉得，哦，红黑树的实现其实也没有想象中的那么困难。

### 旋转操作的实现

红黑树的所有实现细节，其实也都是围绕着 2-3 树的 2、3 节点的诞生和转移展开的，我们就以“插入方法”的实现来具体讨论（仍以左偏红黑树为例）。

红黑树中最基本的自平衡操作就是“旋转”，分为“左旋”和“右旋”两种。这两种操作主要用于处理在插入和删除时产生的右偏红节点或者连续的两个红色节点，通过调整红节点的位置，我们可以修复这些不满足约束的情况。

看“左旋”和“右旋”的具体操作。以左旋为例，本质上就是将某个 3 节点从以较小的键为根转移成较大的键为根，也就是从 a 为根转到 b 为根，当然同时需要把介于 a 和 b 之间的节点挂到 a 的右节点下。这样得到的新树就是以 b 为根结点的结构，并且在整个过程中，树的平衡性和有序性都没有被破坏，而原来不符合约束的右偏红节点已经被转移成“正确”的左偏红节点。

![](./img/2-3树/左旋操作.webp)

现在，我们根据插入时是在“2 节点”还是“3 节点”分开讨论，看看旋转操作具体是如何用于保证约束正确的。

### 2节点插入

首先我们来看针对“2 节点”的插入，对应到红黑树的语境中，也就是针对普通黑色节点的插入。那显然只有两种情况，要么插入在左边，要么插入在右边。

如果插入在左边，非常简单，我们可以直接将 2 节点提升为 3 节点，由于新增的是左侧的红节点，完全不会破坏树的平衡性。对应到红黑树上，就是简单地将新节点放到查找到的最后一个节点的左边。

![](./img/2-3树/2节点插入.webp)

如果插入在右边，其实是一样的，我们也将 2 节点提升成一个不符合“左偏”规则的 3 节点，然后进行一次左旋转即可。由于插入的也是红节点，并不影响树的平衡性。

### 3节点插入

再看插入“3 节点”，情况和操作都会复杂一些，我们根据插入的结点在 3 节点中左键的左侧、右键的右侧和两者之间分开讨论（还是左偏红黑树）。

最简单的情况就是插入在右键的右侧。和 3 节点分解的方式一样，我们只需要把中间的结点提升到上一层，并左右节点变成黑色即可。

![](./img/2-3树/3节点插入01.webp)

而另外两种情况单独看这一个节点的变化，也并不复杂，只需要插入后进行一到两次旋转操作即可。

![](./img/2-3树/3节点插入02.webp)

但这样是不是就完成了所有操作呢？ 并不是。

还有一个很大的问题我们没有处理，就是对 3 节点的操作中，我们虽然保证了“插入操作”对当前子树的“平衡性”没有被破坏，但由于将红色节点变成了黑色，就有可能导致当前子树的黑色节点高度比其他子树高了。

所以我们还需要进行一种叫做“颜色反转”的操作。

每次插入时，最后一步，除了将 3 节点的左右节点都变成黑色，同时要将 3 节点的中间键变成红色，这样当前子树到各个子节点路径中的黑色节点数量就不会有变化啦。

![](./img/2-3树/颜色反转.webp)

当然这个操作是需要递归进行的。因为父节点如果变成红色，也同样可能造成右偏红节点或者连续红节点这样不符合约束的情况，这其实等价于在父节点的父节点下插入了一个新的红节点。我们用类似的逻辑自下而上递归即可，递归的终点就是，遇到根节点我们将其拆分成 3 个“2 节点”，或者遇到某个 2 节点我们将其升级为“3 节点”时，我们就可以结束递归。

讨论好这些 case，我们就可以在整个插入节点的过程中保证不破坏“有序性”和“平衡性”了。

### 总结

**红黑树本质是 2-3 树在二叉树上的一种模拟，通过旋转操作完成 2-3 节点的合并和分裂，从而在不改变二叉树节点结构的前提下，保证二叉树的有序性和平衡性。**