# 排序算法

* 排序算法时间复杂度

![](./img/排序算法复杂度.png)

* 排序算法的内存消耗

  针对排序算法的空间复杂度，引入了一个新的概念：原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

* 排序算法的稳定性

  针对排序算法，还有一个重要的度量指标：**稳定性**。

  如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

  

| 排序算法 | 平均时间复杂度 | 最好情况   | 最坏情况   | 空间复杂度 | 排序方式  | 稳定性 |
| -------- | -------------- | ---------- | ---------- | ---------- | --------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)       | O(n^2)     | O(1)       | In-place  | 稳定   |
| 选择排序 | O(n^2)         | O(n^2)     | O(n^2)     | O(1)       | In-place  | 不稳定 |
| 插入排序 | O(n^2)         | O(n)       | O(n^2)     | O(1)       | In-place  | 稳定   |
| 希尔排序 | O(nlogn)       | O(nlog^2n) | O(nlog^2n) | O(1)       | In-place  | 不稳定 |
| 归并排序 | O(nlogn)       | O(nlogn)   | O(nlogn)   | O(n)       | Out-place | 稳定   |
| 快速排序 | O(nlogn)       | O(nlogn)   | O(n^2)     | O(logn)    | In-place  | 不稳定 |
| 堆排序   | O(nlogn)       | O(nlogn)   | O(nlogn)   | O(1)       | In-place  | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)     | O(n+k)     | O(k)       | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)     | O(n^2)     | O(n+k)     | Out-place | 稳定   |
| 基数排序 | O(nxk)         | O(nxk)     | O(nxk)     | O(n+k)     | Out-place | 稳定   |

* 有序度、逆序度

  **有序度**是数组中具有有序关系的元素对的个数（默认从小到大为有序）。**逆序度**是数组中具有逆序关系的元素对的个数。

  对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作**满有序度**。

  逆序度 = 满有序度 - 有序度

  我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

## 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

每一轮遍历，依次比较两个相邻的元素，如果顺序错误，将这两个元素交换，使得较小的元素放到较大的元素前面，这样，一轮遍历之后，最大的元素被交换到了序列尾部。

```c++
void bubbleSort(int a[], int length)
{
    if (length < 2)
        return;
    for (int i = 0; i < length - 1; i++) //需length-1趟排序确定后length-1个数，剩下第一个数不用排序；
    {
        for (int j = 0; j < length - 1 - i; j++)
        {
            if (a[j + 1] < a[j])
            {
                int temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            }
        }
    }
}

```

优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

```c++
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
  for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

* 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
* 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
* 最好情况时间复杂度 O(n)：要排序的数据已经是有序的了，我们只需要进行一次冒泡操作
* 最坏情况时间复杂度O(n^2)：要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作
* 平均情况时间复杂度O(n^2)

## 插入排序

首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

```c++
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

* 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。

* 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
* 最好情况时间复杂度 O(n)：**从尾到头遍历已经有序的数据**。
* 最坏情况时间复杂度 O(n^2)：如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据
* 平均时间复杂度O(n^2)：在数组中插入一个数据的平均时间复杂度是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。

> 冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
>
> 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
>
> ```c++
> 冒泡排序中数据的交换操作：
> if (a[j] > a[j+1]) { // 交换
>    int tmp = a[j];
>    a[j] = a[j+1];
>    a[j+1] = tmp;
>    flag = true;
> }
> 
> 插入排序中数据的移动操作：
> if (a[j] > value) {
>   a[j+1] = a[j];  // 数据移动
> } else {
>   break;
> }
> ```
>
> 我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。
>
> 所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```c++
// 选择排序，a表示数组，length表示数组大小
void selectSort(int a[], int length)
{
    if (length < 2)
        return;
    for (int i = 0; i < length; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < length; j++) //已确定a[0]~a[i-1],从i-1开始查找最小的数，然后与a[i]交换位置；
        {
            if (a[j] < a[minIndex])
                minIndex = j;
        }
        int temp = a[i];
        a[i] = a[minIndex];
        a[minIndex] = temp;
    }
}
```

* 选择排序空间复杂度为 O(1)，是一种原地排序算法
* 选择排序是一种不稳定的排序算法：选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)

## 希尔排序

希尔排序，也称**递减增量排序算法**，是插入排序的一种更高效的改进版本。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

他的目的是为了减少交换的次数 优化了直接插入算法。希尔排序算法的基本思想是 将待排序的表 按照间隔 切割成若干个子表，然后对这些子表进行 插入排序。 一般来说 第一次的间隔为整个排序表的一半。 然后对按照这些间隔划分的子表进行直接插入排序，第二次间隔又是第一次的一半，然后对按照这些间隔划分的子表进行直接插入排序。一直到间隔等于1为止，此时表内全部的数据都已是有序的。


```c++
//Shell Sort 希尔排序
void shellSort(int a[], int length)
{
    if (length < 2)
        return;
    int gap = length / 2; //整个数组分为gap个组，即每隔 gap-1 个位置的元素为一组
    while (gap > 0)       //最终整个数组分为一组 即所有元素为一组；
    {
        for (int i = gap; i < length; i++)
        {
            int cur = a[i];
            int preIndex = i - gap;
            while (preIndex >= 0 && a[preIndex] > cur) //对每一组元素进行插入排序
            {
                a[i] = a[preIndex];
                preIndex -= gap;
            }
            a[preIndex + gap] = cur;
        }
        gap /= 2;
    }
}
```

wiki版本(https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)：

```c++
template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```



## 归并排序

1、分解(Divide)：将n个元素分成2个包含n/2个元素的子序列

2、解决(Conquer)：用合并排序法对两个子序列递归的排序

3、合并(Combine)：合并两个已排序的子序列得到排序结果

```c++
// 归并排序（C++-递归版）
template<typename T>
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    // 1、分解到最小需要解决的地步，无法再分解了
    if (start >= end)
        return;
    // 2、解决
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start1 到 end1 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start1, end1);
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start2 到 end2 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start2, end2);
    
    // 3、合并
     // 将左右区间中较小的数字存放到 result 中，从 k 开始
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    
    // 最后，把结果赋值到 arr 中
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

// merge_sort
template<typename T>
void merge_sort(T arr[], const int len) {
    T reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
```



## 快速排序

快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：

* **分解**： 将数组 a[l⋯r]「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。
* **解决**： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。
* **合并**： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。
* 上文中提到的 **「划分」** 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。

## 堆排序

1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆

2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端，此时数组末端存储了当前区间最大的元素

3、调整堆，使得它依旧是大顶堆或小顶堆

4、重复2和3的步骤

```c++
#include <iostream>
using namespace std;

//交换函数
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 调整堆
void adjust_heap(int arr[], int i, int n)
{
    int j = 2 * i + 1; // 左子节点索引 
    while (j < n){
        if (j+1 < n && arr[j+1] > arr[j]) // 找到左右子节点中较大的一个 
        {
            j++;
        }
        if (arr[j] > arr[i]) // 如果较大的子节点比父节点大，则交换它们 
        {
            swap(arr[j], arr[i]);
            i = j;
            j = 2 * i + 1;
        }
        else {
            break;
        }
    }
}

// 堆排序
void heap_sort(int arr[], int n)
{
    // 构建初始大根堆 
    for (int i = n/2 - 1; i >= 0; i--)
    {
        adjust_heap(arr, i, n);
    }
    //依次取出堆顶元素，调整堆 
    for (int i = n - 1; i > 0; i--)
    {
        swap(arr[0], arr[i]);
        adjust_heap(arr,0, i);
    }
}

int main()
{
    int arr[] = {1,3,9,6,5,4,7,2,8};
    int n = sizeof(arr) / sizeof(int);
    heap_sort(arr, n);
    for (int i =0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
    system("pause");
    return 0;
}
```



### 时间复杂度

堆的存储表示是**顺序的**。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。

当想得到一个序列中第 **k** 个最小的元素之前的部分排序序列，最好采用堆排序。

因为堆排序的时间复杂度是**O(n+klogn)**，若k≤n/logn，则可得到的时间复杂度为**O(n)**。

### 算法稳定性

堆排序是一种**不稳定**的排序方法。

因为在堆的调整过程中，对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。

## 其他

1.冒泡、插入、选择排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
