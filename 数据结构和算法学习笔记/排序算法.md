# 排序算法

排序算法时间复杂度

![](./img/排序算法复杂度.png)

## 归并排序

1、分解(Divide)：将n个元素分成2个包含n/2个元素的子序列

2、解决(Conquer)：用合并排序法对两个子序列递归的排序

3、合并(Combine)：合并两个已排序的子序列得到排序结果

```c++
// 归并排序（C++-递归版）
template<typename T>
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    // 1、分解到最小需要解决的地步，无法再分解了
    if (start >= end)
        return;
    // 2、解决
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start1 到 end1 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start1, end1);
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start2 到 end2 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start2, end2);
    
    // 3、合并
     // 将左右区间中较小的数字存放到 result 中，从 k 开始
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    
    // 最后，把结果赋值到 arr 中
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

// merge_sort
template<typename T>
void merge_sort(T arr[], const int len) {
    T reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
```



## 快速排序

快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：

* **分解**： 将数组 a[l⋯r]「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。
* **解决**： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。
* **合并**： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。
* 上文中提到的 **「划分」** 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。

## 堆排序

1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆

2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端，此时数组末端存储了当前区间最大的元素

3、调整堆，使得它依旧是大顶堆或小顶堆

4、重复2和3的步骤

```c++
#include <iostream>
using namespace std;

//交换函数
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 调整堆
void adjust_heap(int arr[], int i, int n)
{
    int j = 2 * i + 1; // 左子节点索引 
    while (j < n){
        if (j+1 < n && arr[j+1] > arr[j]) // 找到左右子节点中较大的一个 
        {
            j++;
        }
        if (arr[j] > arr[i]) // 如果较大的子节点比父节点大，则交换它们 
        {
            swap(arr[j], arr[i]);
            i = j;
            j = 2 * i + 1;
        }
        else {
            break;
        }
    }
}

// 堆排序
void heap_sort(int arr[], int n)
{
    // 构建初始大根堆 
    for (int i = n/2 - 1; i >= 0; i--)
    {
        adjust_heap(arr, i, n);
    }
    //依次取出堆顶元素，调整堆 
    for (int i = n - 1; i > 0; i--)
    {
        swap(arr[0], arr[i]);
        adjust_heap(arr,0, i);
    }
}

int main()
{
    int arr[] = {1,3,9,6,5,4,7,2,8};
    int n = sizeof(arr) / sizeof(int);
    heap_sort(arr, n);
    for (int i =0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
    system("pause");
    return 0;
}
```



### 时间复杂度

堆的存储表示是**顺序的**。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。

当想得到一个序列中第 **k** 个最小的元素之前的部分排序序列，最好采用堆排序。

因为堆排序的时间复杂度是**O(n+klogn)**，若k≤n/logn，则可得到的时间复杂度为**O(n)**。

### 算法稳定性

堆排序是一种**不稳定**的排序方法。

因为在堆的调整过程中，对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。

