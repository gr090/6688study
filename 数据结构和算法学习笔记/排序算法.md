# 排序算法

* 排序算法时间复杂度

![](./img/排序算法复杂度.png)

* 排序算法的内存消耗

  针对排序算法的空间复杂度，引入了一个新的概念：原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

* 排序算法的稳定性

  针对排序算法，还有一个重要的度量指标：**稳定性**。

  如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

  

| 排序算法 | 平均时间复杂度 | 最好情况   | 最坏情况   | 空间复杂度 | 排序方式  | 稳定性 |
| -------- | -------------- | ---------- | ---------- | ---------- | --------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)       | O(n^2)     | O(1)       | In-place  | 稳定   |
| 选择排序 | O(n^2)         | O(n^2)     | O(n^2)     | O(1)       | In-place  | 不稳定 |
| 插入排序 | O(n^2)         | O(n)       | O(n^2)     | O(1)       | In-place  | 稳定   |
| 希尔排序 | O(nlogn)       | O(nlog^2n) | O(nlog^2n) | O(1)       | In-place  | 不稳定 |
| 归并排序 | O(nlogn)       | O(nlogn)   | O(nlogn)   | O(n)       | Out-place | 稳定   |
| 快速排序 | O(nlogn)       | O(nlogn)   | O(n^2)     | O(logn)    | In-place  | 不稳定 |
| 堆排序   | O(nlogn)       | O(nlogn)   | O(nlogn)   | O(1)       | In-place  | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)     | O(n+k)     | O(k)       | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)     | O(n^2)     | O(n+k)     | Out-place | 稳定   |
| 基数排序 | O(nxk)         | O(nxk)     | O(nxk)     | O(n+k)     | Out-place | 稳定   |

* 有序度、逆序度

  **有序度**是数组中具有有序关系的元素对的个数（默认从小到大为有序）。**逆序度**是数组中具有逆序关系的元素对的个数。

  对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作**满有序度**。

  逆序度 = 满有序度 - 有序度

  我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

## 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

每一轮遍历，依次比较两个相邻的元素，如果顺序错误，将这两个元素交换，使得较小的元素放到较大的元素前面，这样，一轮遍历之后，最大的元素被交换到了序列尾部。

```c++
void bubbleSort(int a[], int length)
{
    if (length < 2)
        return;
    for (int i = 0; i < length - 1; i++) //需length-1趟排序确定后length-1个数，剩下第一个数不用排序；
    {
        for (int j = 0; j < length - 1 - i; j++)
        {
            if (a[j + 1] < a[j])
            {
                int temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            }
        }
    }
}

```

优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

```c++
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
  for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

* 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
* 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
* 最好情况时间复杂度 O(n)：要排序的数据已经是有序的了，我们只需要进行一次冒泡操作
* 最坏情况时间复杂度O(n^2)：要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作
* 平均情况时间复杂度O(n^2)

## 插入排序(Insertion Sort)

首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

```c++
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

* 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。

* 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
* 最好情况时间复杂度 O(n)：**从尾到头遍历已经有序的数据**。
* 最坏情况时间复杂度 O(n^2)：如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据
* 平均时间复杂度O(n^2)：在数组中插入一个数据的平均时间复杂度是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。

> 冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
>
> 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
>
> ```c++
> 冒泡排序中数据的交换操作：
> if (a[j] > a[j+1]) { // 交换
>    int tmp = a[j];
>    a[j] = a[j+1];
>    a[j+1] = tmp;
>    flag = true;
> }
> 
> 插入排序中数据的移动操作：
> if (a[j] > value) {
>   a[j+1] = a[j];  // 数据移动
> } else {
>   break;
> }
> ```
>
> 我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。
>
> 所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。

## 选择排序(Selection Sort)

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```c++
// 选择排序，a表示数组，length表示数组大小
void selectSort(int a[], int length)
{
    if (length < 2)
        return;
    for (int i = 0; i < length; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < length; j++) //已确定a[0]~a[i-1],从i-1开始查找最小的数，然后与a[i]交换位置；
        {
            if (a[j] < a[minIndex])
                minIndex = j;
        }
        int temp = a[i];
        a[i] = a[minIndex];
        a[minIndex] = temp;
    }
}
```

* 选择排序空间复杂度为 O(1)，是一种原地排序算法
* 选择排序是一种不稳定的排序算法：选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)

## 希尔排序(Shell Sort)

希尔排序，也称**递减增量排序算法**，是插入排序的一种更高效的改进版本。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

他的目的是为了减少交换的次数 优化了直接插入算法。希尔排序算法的基本思想是 将待排序的表 按照间隔 切割成若干个子表，然后对这些子表进行 插入排序。 一般来说 第一次的间隔为整个排序表的一半。 然后对按照这些间隔划分的子表进行直接插入排序，第二次间隔又是第一次的一半，然后对按照这些间隔划分的子表进行直接插入排序。一直到间隔等于1为止，此时表内全部的数据都已是有序的。


```c++
//Shell Sort 希尔排序
void shellSort(int a[], int length)
{
    if (length < 2)
        return;
    int gap = length / 2; //整个数组分为gap个组，即每隔 gap-1 个位置的元素为一组
    while (gap > 0)       //最终整个数组分为一组 即所有元素为一组；
    {
        for (int i = gap; i < length; i++)
        {
            int cur = a[i];
            int preIndex = i - gap;
            while (preIndex >= 0 && a[preIndex] > cur) //对每一组元素进行插入排序
            {
                a[i] = a[preIndex];
                preIndex -= gap;
            }
            a[preIndex + gap] = cur;
        }
        gap /= 2;
    }
}
```

wiki版本(https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)：

```c++
template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```



## 归并排序(Mergesort)

归并排序的核心思想：如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

```c++
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

1、分解(Divide)：将n个元素分成2个包含n/2个元素的子序列

2、解决(Conquer)：用合并排序法对两个子序列递归的排序

3、合并(Combine)：合并两个已排序的子序列得到排序结果

> 归并排序伪代码
>
> ```c++
> // 归并排序算法, A是数组，n表示数组大小
> merge_sort(A, n) {
>   merge_sort_c(A, 0, n-1)
> }
> 
> // 递归调用函数
> merge_sort_c(A, p, r) {
>   // 递归终止条件
>   if p >= r  then return
> 
>   // 取p到r之间的中间位置q
>   q = (p+r) / 2
>   // 分治递归
>   merge_sort_c(A, p, q)
>   merge_sort_c(A, q+1, r)
>   // 将A[p...q]和A[q+1...r]合并为A[p...r]
>   merge(A[p...r], A[p...q], A[q+1...r])
> }
> ```
>
> 

```c++
// 归并排序（C++-递归版）
template<typename T>
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    // 1、分解到最小需要解决的地步，无法再分解了
    if (start >= end)
        return;
    // 2、解决
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start1 到 end1 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start1, end1);
    // 调用 merge_sort_recursive 函数，将 arr 数组中的 start2 到 end2 这一区间的数字排序后，并存放到 reg 中
    merge_sort_recursive(arr, reg, start2, end2);
    
    // 3、合并
     // 将左右区间中较小的数字存放到 result 中，从 k 开始
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    
    // 最后，把结果赋值到 arr 中
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

// merge_sort
template<typename T>
void merge_sort(T arr[], const int len) {
    T reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
```

* 归并排序是一个稳定的排序算法
* 归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
* 归并排序不是原地排序算法。这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。空间复杂度是 O(n)。

## 快速排序(Quicksort)

快速排序的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

```c++
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p >= r
```

快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：

* **分解**： 将数组 a[l⋯r]「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。
* **解决**： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。
* **合并**： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。
* 上文中提到的 **「划分」** 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。

> 快排伪代码
>
> ```c++
> // 快速排序，A是数组，n表示数组的大小
> quick_sort(A, n) {
>   quick_sort_c(A, 0, n-1)
> }
> // 快速排序递归函数，p,r为下标
> quick_sort_c(A, p, r) {
>   if p >= r then return
>   
>   q = partition(A, p, r) // 获取分区点
>   quick_sort_c(A, p, q-1)
>   quick_sort_c(A, q+1, r)
> }
> ```
>
> partition() 原地分区函数伪代码
>
> ```c++
> partition(A, p, r) {
>   pivot := A[r]
>   i := p
>   for j := p to r-1 do {
>     if A[j] < pivot {
>       swap A[i] with A[j]
>       i := i+1
>     }
>   }
>   swap A[i] with A[r]
>   return i
> 
> ```
>
> 处理有点类似选择排序。我们通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。



利用哨兵减少了交换两个元素的复杂步骤

```c++
//Quick Sort 快速排序
void quickSort(int a[], int left, int right)
{
    if (left >= right)
        return;
    int key = a[left]; //以第一个数为基数进行快排；
    int pointL = left, pointR = right;

    while (pointL < pointR)
    {
        //一定要先动右指针，否则右指针所指向的元素无处存放
        while (pointR > pointL && a[pointR] >= key) //若右指针指向的元素大于key 则右指针左移，直到右指针指向的元素小于key 或者 左右指针坐标相同
            pointR--;
        a[pointL] = a[pointR]; //把这个小于key的元素放到key的左边，即左指针指向的位置

        while (pointR > pointL && a[pointL] <= key) //若左指针指向的元素小于key 则左指针右移，直到左指针指向的元素大于key 或者 左右指针坐标相同
            pointL++;
        a[pointR] = a[pointL]; //把这个大于key的元素放到key的右边，即右指针指向的位置
    }
    a[pointR] = key; //此时左右指针指向同一位置，这个位置就是key应该放的位置

    //对key两边的元素同样使用快排
    quickSort(a, left, pointR - 1);
    quickSort(a, pointR + 1, right);
}
```

* 快排是一种原地、不稳定的排序算法。

* 快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？

  归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

* 最坏情况下的时间复杂度是 O(n^2)，平均情况下时间复杂度是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n^2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。

## 堆排序(Heapsort)

1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆

2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端，此时数组末端存储了当前区间最大的元素

3、调整堆，使得它依旧是大顶堆或小顶堆

4、重复2和3的步骤

```c++
#include <iostream>
using namespace std;

//交换函数
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 调整堆
void adjust_heap(int arr[], int i, int n)
{
    int j = 2 * i + 1; // 左子节点索引 
    while (j < n){
        if (j+1 < n && arr[j+1] > arr[j]) // 找到左右子节点中较大的一个 
        {
            j++;
        }
        if (arr[j] > arr[i]) // 如果较大的子节点比父节点大，则交换它们 
        {
            swap(arr[j], arr[i]);
            i = j;
            j = 2 * i + 1;
        }
        else {
            break;
        }
    }
}

// 堆排序
void heap_sort(int arr[], int n)
{
    // 构建初始大根堆 
    for (int i = n/2 - 1; i >= 0; i--)
    {
        adjust_heap(arr, i, n);
    }
    //依次取出堆顶元素，调整堆 
    for (int i = n - 1; i > 0; i--)
    {
        swap(arr[0], arr[i]);
        adjust_heap(arr,0, i);
    }
}

int main()
{
    int arr[] = {1,3,9,6,5,4,7,2,8};
    int n = sizeof(arr) / sizeof(int);
    heap_sort(arr, n);
    for (int i =0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
    system("pause");
    return 0;
}
```

* 堆的存储表示是**顺序的**。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。当想得到一个序列中第 **k** 个最小的元素之前的部分排序序列，最好采用堆排序。因为堆排序的时间复杂度是**O(n+klogn)**，若k≤n/logn，则可得到的时间复杂度为**O(n)**。

* 堆排序是一种**不稳定**的排序方法。因为在堆的调整过程中，对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。

## 计数排序(Counting Sort)

创建一个计数数组count。以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值

**步骤一**：扫描待排序数据arr[N]，使用计数数组counting[MAX-MIN]，对每一个arr[N]中出现的元素进行计数；

**步骤二**：扫描计数数组counting[]，还原arr[N]，排序结束；

```c++
//Counting Sort 计数排序
void countingSort(int a[], int length)
{
    if (length < 2)
        return;
    int min = a[0], max = a[0];
    int bios; //偏移量

    for (int i = 0; i < length; i++) //找最大最小值
    {
        if (a[i] < min)
            min = a[i];
        if (a[i] > max)
            max = a[i];
    }

    bios = 0 - min;
    vector<int> count(max - min + 1, 0);

    for (int i = 0; i < length; i++) //把出现了的元素作为count的下标 计数
    {
        count[a[i] + bios]++;
    }

    int index = 0;
    for (int i = 0; i < max - min + 1; i++) //顺序扫描一遍vector即可
    {
        while (count[i])
        {
            a[index++] = i - bios;
            count[i]--;
        }
    }
}
```

如果要排序的是对象，需要对计数数组依次累加求和，转为计数前缀和数组，然后从后往前遍历原数组(从后往前是为了确保稳定排序)，根据计数前缀和数组，定位每个对象在有序数组中对应的位置。

```c++

// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```

* 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

## 桶排序(Bucket Sort)

桶排序，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

```c++
//Bucket Sort 桶排序
void bucketSort(int a[], int length)
{
    if (length < 2)
        return;
    int min = a[0], max = a[0];
    for (int i = 0; i < length; i++)
    {
        if (a[i] < min)
            min = a[i];
        if (a[i] > max)
            max = a[i];
    }

    int buckNum = (max - min) / length + 1; //桶的数量
    vector<vector<int>> bucketArr;
    for (int i = 0; i < buckNum; i++)
    {
        vector<int> temp;
        bucketArr.push_back(temp);
    }

    //每个元素入桶
    for (int i = 0; i < length; i++)
    {
        int num = (a[i] - min) / length;
        bucketArr[num].push_back(a[i]);
    }

    //对每个桶排序 并且排序完后赋值
    int index = 0;
    for (int i = 0; i < bucketArr.size(); i++)
    {
        if (bucketArr[i].size())
        {
            sort(bucketArr[i].begin(), bucketArr[i].end()); //快排
            for (int j = 0; j < bucketArr[i].size(); j++)
            {
                a[index++] = bucketArr[i][j];
            }
        }
    }
}
```

* 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

* 桶排序对要排序数据的要求是非常苛刻的。

  首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。

  其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

* 桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。如磁盘的读写可以分成多个小文件并对每个小文件排序，然后直接写到大文件里。

* 稳定性: 取决于每个桶的排序方式，快排就不稳定，归并就稳定。

  

## 基数排序(Radix Sort)

按位分割，按照每位来排序。根据每一位用桶排序或者计数排序

```c++
//Base Sort 基数排序
void baseSort(int a[], int length) 
{
    //得到最大位数；
    int max = a[0];
    int d = 0;//最大位数
    for (int i = 0; i < length; i++)
    {
        if (a[i] > max)
            max = a[i];
    }
    while (max)
    {
        max /= 10;
        d++;
    }

    int factor = 1;
    for (int i = 1; i <= d; i++) //从个位数排到d位数
    {
        vector<int> bucket[10]; //初始化十个桶
        for (int i = 0; i < length; i++)
        {
            int temp = (a[i] / factor) % 10; //得到a[i]的now_d位数，并放入对应桶中
            bucket[temp].push_back(a[i]);
        }
        int j = 0;
        for (int i = 0; i < 10; i++) //遍历十个桶，按从小到大顺序放入原数组
        {
            int size = bucket[i].size();
            for (int k = 0; k < size; k++)
            {
                a[j++] = bucket[i][k];
            }
            bucket[i].clear(); //桶置空
        }
        factor *= 10;
    }
}
```

* 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。
* 根据每一位来排序，用桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。
* 有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。

## 其他

1. 冒泡、插入、选择排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

   有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。

2. 如何在O(n) 时间复杂度内求无序数组中的第 K 大元素？

   使用快排分区的思想。

   选择数组区间 A[0...n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，我们再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0...p-1]区间查找。

   为什么上述解决思路的时间复杂度是 O(n)？第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。
   
3. TopK问题：从arr[1, n]这n个数中，找出最大的k个数

   * 全局排序 O(nlogn)

     将n个数排序之后，取出最大的k个

   * 局部排序 O(n*k)

     每冒一个泡，找出最大值，冒k个泡，就得到TopK

   * 堆 O(n*log(k))

     思路：只找到TopK，不排序TopK。

     先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是TopK。

     伪代码：

     ```c++
     heap[k] = make_heap(arr[1, k]);
     for(i=k+1 to n){
       adjust_heap(heep[k],arr[i]);
     }
     return heap[k];
     ```

   * 随机选择+partition O(n)

     通过随机选择（randomized_select），找到arr[1, n]中第k大的数，再进行一次partition，就能得到TopK的结果。

     随机选择算法伪代码如下：

     ```c++
     int RS(arr, low, high, k){
       if(low== high) return arr[low];
       i= partition(arr, low, high);
       temp= i-low; //数组前半部分元素个数
       if(temp>=k)
           return RS(arr, low, i-1, k); //求前半部分第k大
       else
           return RS(arr, i+1, high, k-i); //求后半部分第k-i大
     }
     ```

     
