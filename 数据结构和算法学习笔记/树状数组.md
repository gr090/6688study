# 树状数组

树状数组，常用于高效处理「一个数组的更新以及前缀和的求取」。具体来说，其常用于高效求解如下问题：

```markdown
给定一个长度为 n 的数组 nums，需要支持两类操作：
操作 1: 将 nums[i] 的数值增加 v
操作 2: 求取 nums[1] + nums[2] + ... + nums[i] 的值
```

对于上述问题，如果我们采用直接的做法，则操作 1 的时间复杂度为 O(1)，操作 2 的时间复杂度为 O(n)。假如一共有 q 次操作，则总的时间复杂度为 O(qn)。

而如果使用树状数组来求解，则操作 1 和操作 2 的时间复杂度均为 O(log(n))。假如一共有 q 次操作，则总的时间复杂度为 O(qlog(n))。对比之前的做法，树状数组的解法在时间复杂度上有根本性的优势，而这也正是我们学习该算法的原因。

树状数组加快运算的关键，在于对二进制的进一步挖掘，因此我们首先来回忆一下二进制。

以正整数 29 为例，其二进制为 11101，因此 29 可以根据其二进制进一步表示为：
$$
29=2^4+2^3+2^2+2^0
$$
根据这一特点，我们可以重新思考之前的「操作 2」，即如何快速求取数组 [1, 29] 的和？

仿照之前对 29 的二进制拆分，我们也可以将 [1, 29] 拆分成如下四个区间的相加：
$$
[1,29]=[1,2^4]+
[2^4+1,2^4+2^3]+
[2^4+2^3+1,2^4+2^3+2^2]+
[2^4+2^3+2^2+1,2^4+2^3+2^2+2^0]
$$
观察上述四个区间，可以发现四个区间的长度依次为$2^4、2^3、2^2、2^0$。并且对于每一个区间来说，其区间长度恰好等于「区间右端点二进制中最低位的 1 对应的数值」。以区间$[2^4+1,2^4+2^3]$为例，其区间长度为$2^3$，而其区间右端点为$2^4+2^3$，二进制为11000，其中最低位的 1 在第 3 位，对应的数值为$2^3$，恰好等于其区间长度。

## lowbit(x)

为了更好地形式化描述上述观察，我们引入 lowbit(x) 函数，表示「x 二进制中最低位的 1 对应的数值」。例如 29，其二进制为 11101，则最低位的 1 在第 0 位，对应的数值为$2^0$，即lowbit(29) = 1。再比如 16，其二进制为 10000，则最低位的 1 在第 4 位，对应的数值为 $2^4$，即lowbit(16)=16。

理解完 lowbit(x) 的功能后，我们给出其代码形式：

```c++
int lowbit(x) {
    return x & (-x);
}
```

代码非常短，但想要理解却需要一些原码、补码的知识。简单来说，在计算机中，所有整数都是用补码的形式来存储的，对于正整数 x 来说，其补码形式就是其二进制的形式。但对于负数 -x 来说，我们需要将 x 的二进制形式按位取反再加 1。

## 原理讲解

有了 lowbit(x) 函数，我们可以更容易地表示 [1, 29] 的拆分形式：

[1,29] = [16-lowbit(16)+1,16]+

​              [24-lowbit(24)+1,24]+

​              [28-lowbit(28)+1,28]+

​              [29-lowbit(29)+1,29]

由此一来，我们可以更容易地发现四个区间的长度依次为 lowbit(16)、lowbit(24)、lowbit(28)、lowbit(29)，即$2^4、2^3、2^2、2^0$。

到了这一步，我们便推导出了树状数组 c 的含义，即 c[x] 表示区间 [x - lowbit(x) + 1,x] 的和，即：
$$
c[x] = \sum_{i=x-lowbit(x)+1}^xnums[i]
$$
因此[1,29]的和可以表示为：
$$
\sum_{i=1}^{29}nums[i]=c[29]+c[28]+c[24]+c[16]
$$
除此之外，我们还可以发现：
$$
\begin{Bmatrix}
28=29-lowbit(29)\\
24=28-lowbit(28)\\
16=24-lowbit(24)
\end{Bmatrix}
$$
由此，我们可以得到树状数组关于操作 2，即求取 [1, x] 区间和的代码：

```c++
int query(int x) {
    int res = 0;
    // 当 i 等于 0 时，退出 for 循环
    for (int i = x; i; i -= lowbit(i)) res += c[i];
    return res;
}
```

至此，还剩下一个函数未讲解。即对于操作 1 来说，当 nums[i] 的数值增加了 v，树状数组 c 该如何变化？

由于 c[x] 表示区间 [x - lowbit(x) + 1, x] 的和，因此我们只需要将所有覆盖了 nums[i] 的 c[x] 均加上 v 即可。由此问题转变为了「如何寻找到所有覆盖了 nums[i] 的 c[x]」？

寻找的方法非常简单，我们先直接给出代码：

```c++
void update(int x, int v) {
    // n 为树状数组的长度
    for (int i = x; i <= n; i += lowbit(i)) c[i] += v;
}
```

观察上述代码，我们可以发现只需要令 i 不断加上 lowbit(i)，即可更新所有对应区间覆盖了 nums[i] 的 c[x]。

想要理解这个结论，我们需要先思考 i + lowbit(i) 究竟意味着什么？

我们假设 nums[i] = 109，查看 nums[i] 能否通过不断加 lowbit(i) 更新到 c[128]，即对应 [1, 128] 的区间。

109 的二进制为 01101101，其不断加 lowbit(i) 的结果如下：
$$
\begin{Bmatrix}
109=01101101\\
109+lowbit(109)=110=01101110\\
110+lowbit(110)=112=01110000\\
112+lowbit(112)=128=10000000\\
\end{Bmatrix}
$$
观察上述结果，最终的确更新到了 128。事实上，109 对应的二进制中，「最低位的 1 前面的 0」的位置分别是 1、4、7。在其不断加 lowbit(i) 的过程中，最低位的 1 不断向前挪到最近的一个 0，即 110、112、128 最低位的 1 分别为 1、4、7。

因此我们可以发现，不断加 lowbit(i) 的过程，即为将二进制中最低位的 1 不断向前挪到最近的一个 0 的过程。

回到前面的问题，「为何令 i 不断加上 lowbit(i)，即可更新所有对应区间覆盖了 nums[i] 的 c[x]」？

我们假设 c[x] 对应的区间 [x - lowbit(x) + 1, x] 覆盖了 nums[i]，且 c[x] 最低位 1 的位置为 pos。则 nums[i] 的二进制形式在 [0, pos] 位中必定存在 1。

此时分两种情况，若 nums[i] 二进制的 pos 位为 1，则 nums[i] = x；若 nums[i] 二进制的 pos 位不为 1，则 nums[i] 在不断加 lowbit(i) 的过程中，最低位的 1 一定会挪到 pos 位，即在加 lowbit(i) 的过程中达到 x，由此可以证明之前的结论。

## 树形结构

讲解完树状数组的原理后，我们再给出树状数组的树形图，来帮助大家进一步理解该数据结构。

![树形结构](.\img\树形结构示意图.png)

上图最下边一行为 nums 数组，代表 n 个叶节点，其上方为树状数组 c，满足以下 5 条性质：

1. 每个内部节点 c[x] 保存以它为根的子树中所有叶节点的和
2. 每个内部节点 c[x] 的值等于其子节点值的和
3. 每个内部节点 c[x] 的子节点个数为 lowbit(x) 的位数
4. 除树根外，每个内部节点 c[x] 的父节点为 c[x + lowbit(x)]
5. 树的深度为 O(log(n))，其中 n 表示 nums 数组的长度

总结一下，树状数组支持在 O(log(n)) 的时间复杂度内「求数组区间和」或「更新数组中某一点的值」，其完整代码如下所示：

```c++
int n; // 树状数组长度
vector<int> c;

int lowbit(x) {
    return x & (-x);
}

void update(int x, int v) {
    for (int i = x; i <= n; i += lowbit(i)) c[i] += v;
}

int query(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += c[i];
    return res;
}
```

