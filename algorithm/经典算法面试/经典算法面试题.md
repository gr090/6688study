# 经典算法面试题

## 1. 龟兔赛跑判断链表是否带环

* 题目

  有一个单链表，已知其头指针，判断它是否带环？要求时空复杂度尽可能低。

* 分析

  一、 标记解法。把走过结点的地址，塞入到hashmap中，每走过一个结点，就判断结点地址是否已在hashmap中。可是，这里引入了哈希表，所以，空间复杂度就是O(N)了。

  二、龟兔赛跑。

  利用龟兔赛跑的启发，我们可以有比较圆满的解答，让时间复杂度和空间复杂度尽可能低。对于直赛道而言，在龟兔赛跑中，乌龟是永远没法追赶上兔子的。对于环形赛道而言，兔子的速度远大于乌龟，所以，总有一天，兔子会再次追上乌龟。受此启发，我们可以在链表中考虑快慢指针，快指针每次走2步，慢指针每次走1步

* 解答

  [ListHasRing.cpp](./ListHasRing.cpp)

  ```c++
  #include<iostream>
  using namespace std;
   
  typedef struct node
  {
      int data;  
      struct node *next;
  }Node;
   
  Node *createList(int n)
  {
      Node *p = new Node[n];
      for( int i = 1; i < n; ++i)
      {
          p[i - 1].next = &p[i];
          p[i - 1].data = i;
      }
      p[n - 1].next = NULL;
      p[n - 1].data = n;
      return p;
  }
   
  Node *createListWithRing(int n)
  {
      Node *p = new Node[n];
      for( int i = 1; i < n; ++i)
      {
          p[i - 1].next = &p[i];
          p[i - 1].data = i;
      }
      p[n - 1].next = &p[n/2];
      p[n - 1].data = n;
      return p;
  }
   
  //pFast相当于兔子，pSlow相当于乌龟
  bool listHasRing(Node *p)
  {
      Node *pSlow = &p[0];
      Node *pFast = &p[1];
      while(NULL != pSlow && NULL != pFast -> next) 
      {
          if(pSlow == pFast)
      {
        return true;
      }
  
          pSlow = pSlow -> next;
          pFast = pFast -> next ->next;
      }
    
      return false;
  }
  
   
  int main()
  {
      Node *head = createList(10);
      cout << listHasRing(head) << endl;
      delete [] head; 
   
      head = createListWithRing(10);
      cout << listHasRing(head) << endl;
      delete [] head; 
      return 0;
  }
  ```

## 2. 删除未知头节点的链表节点

* 题目

  有一个足够长的单链表，并且头指针未知。靠近中间位置附近有一个结点，指针是p，请把该结点删除。

* 分析

  要删除p指向的节点，就得把p前面的节点和后面的节点连接上，这样才能形成删除后的链表。可是，现在的问题是不知道单链表的头指针，所以也就没法知道p前面节点的指针。

  可以考虑先把p节点的值改一下，然后考虑把p后面的节点删除。

* 解答

  ```c++
  // 先把p节点的值改一下
  p->data = p->next->data;
  // 然后把p后面的节点删除
  q = p->next;
  p->next = p->next->next;
  free(q);
  ```

  