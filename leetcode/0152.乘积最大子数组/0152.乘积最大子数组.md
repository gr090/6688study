# 152.乘积最大子数组

## 题目描述 

https://leetcode.cn/problems/maximum-product-subarray

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**子数组** 是数组的连续子序列。

 

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

 

**提示:**

- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`
- `nums` 的任何前缀或后缀的乘积都 **保证** 是一个 **32-位** 整数



## 题目分析

动态规划

我们用 $f_{max}⁡(i)$ 来表示以第 i 个元素结尾的乘积最大子数组的乘积。

考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $f_{min}(i)$，它表示以第 i 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

$$
f_{max}⁡(i)=max_{i=1}^n\{f_{max}(i-1)*a_i,f_{min}(i-1)*a_i,a_i\}\\

f_{min}⁡(i)=min_{i=1}^n\{f_{max}(i-1)*a_i,f_{min}(i-1)*a_i,a_i\}
$$
它代表第 i 个元素结尾的乘积最大子数组的乘积$f_{max}(i)$，可以考虑把$a_i$加入第 i-1个元素结尾的乘积最大或最小的子数组的乘积中，二者加上$a_i$，三者取大，就是第 i 个元素结尾的乘积最大子数组的乘积。第 i 个元素结尾的乘积最小子数组的乘积$f_{min}(i)$同理。



由于第 i 个状态只和第 i−1 个状态相关，根据「滚动数组」思想，我们可以只用两个变量来维护 i−1 时刻的状态，一个维护 $f_{max}⁡$，一个维护 $f_{min⁡}$。



## 题目解答

C++代码

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        for(int i = 1; i < nums.size(); i++){
            int mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max(mn * nums[i], nums[i]));
            minF = min(mn * nums[i], min(mx * nums[i], nums[i]));
            ans = max(maxF, ans);
        }
        return ans;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：程序一次循环遍历了 `nums`，故渐进时间复杂度为 O(n)。
* 空间复杂度：优化后只使用常数个临时变量作为辅助空间，与 n 无关，故渐进空间复杂度为 O(1)。

