# 3.无重复字符的最长字串

## 题目描述

给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是"abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是"b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0 
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters

## 题目分析

本题是一个字符串处理问题。首先我们明确知道问题的求解是最长不重复字串长度。最长不重复字串可能有多个，而最长不重复字串长度只有一个唯一的值。

* 解决思路一：暴力求解法

  通过两层循环，内层循环统计从当前字符开始最长不重复字串长度，外层循环比较从不同字串开始最长字串长度，保存最大的长度。

  复杂度分析：

  时间复杂度：使用了两层循环，复杂度达到O($n^2$)，而每次判断字串是否为重复串的复杂度为O(n)，因此算法的时间复杂度为O($n^3$)。

  空间复杂度：O(m)

* 解决思路二：滑动窗口及优化

  模式识别1: 一旦涉及出现次数，需要用到散列表

  构造字串，散列表存下标

  模式识别2: 涉及字串，考虑滑动窗口

  如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为$r_k$。那么当我们选择第k+1个字符作为起始位置时，首先从k+1到 $r_k$的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大$r_k$，直到右侧出现了重复字符为止。

  这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

  * 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的$r_k$；

  * 在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

  * 在枚举结束后，我们找到的最长的子串的长度即为答案。

  * 判断重复字符

    在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

  复杂度分析：

  时间复杂度：O(N)，其中N是字符串的长度。左指针和右指针分别会遍历整个字符串一次。

  空间复杂度：O(∣Σ∣)，其中Σ表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有∣Σ∣ 个，因此空间复杂度为O(∣Σ∣)。


## 题目解答

C++代码

```c++
/**

 */
class Solution {
public:
 
}
```

TypeScript代码

```typescript
/**

 */
function func(): XXX | null {

};
```

