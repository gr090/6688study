# 67.二进制求和

## 题目描述 

https://leetcode.cn/problems/add-binary

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

 

**示例 1：**

```
输入:a = "11", b = "1"
输出："100"
```

**示例 2：**

```
输入：a = "1010", b = "1011"
输出："10101"
```

 

**提示：**

- `1 <= a.length, b.length <= 104`
- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
- 字符串如果不是 `"0"` ，就不含前导零



## 题目分析

我们可以借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。

具体的，我们可以取 n=max⁡{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 ai和 bi，则每一位的答案为 (carry+ai+bi) mod 2，下一位的进位为 $⌊\frac{carry+ai+bi}2⌋$。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。

注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。



## 题目解答

C++代码

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int carry = 0;
        string res = "";
        for(int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--,j--){
            int sum = carry;
            sum += i >= 0 ? a[i] - '0' : 0;
            sum += j >= 0 ? b[j] - '0' : 0;
            res += (sum % 2) + '0';
            carry = sum / 2;
        }

        if(carry == 1) res += '1';
        reverse(res.begin(), res.end());
        return res;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(n)，这里的时间复杂度来源于顺序遍历 a 和 b。
* 空间复杂度：*O*(1)，除去答案所占用的空间，这里使用了常数个临时变量。

