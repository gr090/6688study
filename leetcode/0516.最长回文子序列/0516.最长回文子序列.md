# 516.最长回文子序列

## 题目描述 

https://leetcode.cn/problems/longest-palindromic-subsequence

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成



## 题目分析

动态规划

对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。



dp\[i][j]表示字符串 s 第 i 个字符和字符串 s 第 j 个字符之间的最长的回文子序列的长度

当 i<j 时，计算 dp\[i][j] 需要分别考虑 s[i] 和 s[j] 相等和不相等的情况：

* 如果 s[i]=s[j]，则首先得到 s 的下标范围 \[i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和 s[j]，即可得到 s 的下标范围 \[i,j] 内的最长回文子序列，因此 dp\[i][j]=dp\[i+1][j−1]+2；

* 如果 s[i]≠s[j]，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此 dp\[i][j]=max⁡(dp\[i+1][j],dp\[i][j−1])。



状态转移方程：
$$
dp[i][j]= \left\{
\begin{aligned}
&dp[i+1][j-1]+2,&s[i]==s[j]\\
&max(dp[i][j-1], dp[i+1][j]),&s[i]!=s[j]
\end{aligned}
\right.
$$
最终得到 dp\[0][n−1] 即为字符串 s 的最长回文子序列的长度。



## 题目解答

C++代码

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int len = s.length();
        // 设置数组 dp，用来存储字符串 s 的最长的回文子序列的长度
        auto dp = vector<vector<int>> (len ,vector<int>(len));

        // dp[i][i]，这个区间的字符只有一个，最长的回文子序列的长度为 1
        for(int i = 0; i < len; i++){
            dp[i][i] = true;
        }

        // i 从字符串 s 的【尾部】开始向前遍历，j 从 i + 1 开始向后遍历
        // 不断的逼近二维数组最右上角的位置，即求 dp[0][length - 1]
        for (int i = len - 1; i >= 0; i--) {
           for( int j = i + 1; j < len; j++ ){
                if(s[i] == s[j]){
                    // 由于扩充的两个字符相等，意味着最长的回文子序列的长度加 2
                    dp[i][j] = dp[i+1][j-1] + 2;
                }
                else{
                   // 字符区间 s[i..j] 里最长回文子序列的长度
                   // 1、去掉头以后的区间的最长的回文子序列的长度，即 dp[i + 1][j]
                   // 2、去掉尾以后的区间的最长的回文子序列的长度，即  dp[i][j - 1]
                   // 二者取最大值                    
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
           }
        }

        return dp[0][len - 1];
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(n^2^)，其中 n 是字符串 s 的长度。动态规划需要计算的状态数是 O(n^2^)。

* 空间复杂度：O(n^2^)，其中 n 是字符串 s 的长度。需要创建二维数组 dp，空间是 O(n^2^)。

  

