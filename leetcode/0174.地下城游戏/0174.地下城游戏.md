# 174.地下城游戏

## 题目描述 

https://leetcode.cn/problems/dungeon-game

恶魔们抓住了公主并将她关在了地下城 `dungeon` 的 **右下角** 。地下城是由 `m x n` 个房间组成的二维网格。我们英勇的骑士最初被安置在 **左上角** 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为*负整数*，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 *0*），要么包含增加骑士健康点数的魔法球（若房间里的值为*正整数*，则表示骑士将增加健康点数）。

为了尽快解救公主，骑士决定每次只 **向右** 或 **向下** 移动一步。

返回确保骑士能够拯救到公主所需的最低初始健康点数。

**注意：**任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

**示例 1：**

```
输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
输出：7
解释：如果骑士遵循最佳路径：右 -> 右 -> 下 -> 下 ，则骑士的初始健康点数至少为 7 。
```

**示例 2：**

```
输入：dungeon = [[0]]
输出：1
```

 

**提示：**

- `m == dungeon.length`
- `n == dungeon[i].length`
- `1 <= m, n <= 200`
- `-1000 <= dungeon[i][j] <= 1000`



## 题目分析

动态规划

如果按照从左上往右下的顺序进行动态规划，对于每一条路径，我们需要同时记录两个值。第一个是「从出发点到当前点的路径和」，第二个是「从出发点到当前点所需的最小初始值」。而这两个值的重要程度相同。因为有两个重要程度相同的参数同时影响后续的决策。也就是说，这样的动态规划是不满足「无后效性」的。

于是我们考虑从右下往左上进行动态规划。令 dp\[i][j] 表示从坐标 (i,j) 到终点所需的最小初始值。换句话说，当我们到达坐标 (i,j) 时，如果此时我们的路径和不小于 dp\[i][j]，我们就能到达终点。

这样一来，我们就无需担心路径和的问题，只需要关注最小初始值。对于 dp\[i][j]，我们只要关心 dp\[i][j+1] 和 dp\[i+1][j] 的最小值 minn。记当前格子的值为 dungeon(i,j)，那么在坐标 (i,j) 的初始值只要达到 minn−dungeon(i,j) 即可。同时，初始值还必须大于等于 1。这样我们就可以得到状态转移方程：

$$
dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon(i,j),1)
$$
最终答案即为dp\[0][0]。



## 题目解答

C++代码

```c++
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m = dungeon.size();
        int n = dungeon[0].size();
        // dp[i][j] 表示骑士来到第 i 行第 j 列时必须拥有的最小生命值
        vector<vector<int>> dp(m, vector<int>(n));

        // 先计算最右下角的值
        if(dungeon[m-1][n-1] >= 0){
            dp[m-1][n-1] = 1;
        }else{
            dp[m-1][n-1] = 1- dungeon[m-1][n-1];
        }

        // 当骑士来到最后一列的时候，他只能向下移动
        for(int i = m - 2 ; i >= 0 ; i--){
            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1]);
        }

        // 当骑士来到最后一行的时候，他只能向右移动
        for(int j = n - 2 ; j >= 0 ; j--){
            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j]);
        }

        // 从右下角开始向左上角推导
        // 相当于公主救骑士
        for(int i = m - 2 ; i >= 0 ; i--){
            for(int j = n - 2 ; j >= 0 ; j--){
                int mmin = min(dp[i+1][j], dp[i][j+1]);
                dp[i][j] = max(1, mmin - dungeon[i][j]);
            }
        }

        return dp[0][0];
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(N×M)，其中 N,M 为给定矩阵的长宽。
* 空间复杂度：*O*(N×M)，其中 N,M 为给定矩阵的长宽，注意这里可以利用滚动数组进行优化，优化后空间复杂度可以达到 O(N)。

