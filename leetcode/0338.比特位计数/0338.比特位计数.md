# 338.比特位计数

## 题目描述 

https://leetcode.cn/problems/counting-bits

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

 

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

 

**提示：**

- `0 <= n <= 10^5`

 

**进阶：**

- 很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？
- 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 `__builtin_popcount` ）



## 题目分析

动态规划——最低设置位

令 y=x & (x−1)，则 y 为将 x 的二进制表示中最低的1所在位从 1 变成 0 之后的数，显然 0≤y<x，bits[x]=bits[y]+1。因此对任意正整数 x，都有 bits[x]=bits[x & (x−1)]+1。

遍历从 1 到 n 的每个正整数 i，计算 bits 的值。最终得到的数组 bits 即为答案。



## 题目解答

C++代码

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n+1, 0);
        for(int i = 1; i <= n; i++){
            bits[i] = bits[i & (i-1)] + 1;
        }
        return bits;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(*n*)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。
* 空间复杂度：*O*(1)。除了返回的数组以外，空间复杂度为常数。

