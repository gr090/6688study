# 224.基本计算器

## 题目描述 

https://leetcode.cn/problems/basic-calculator/

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1：**

```
输入：s = "1 + 1"
输出：2
```

**示例 2：**

```
输入：s = " 2-1 + 2 "
输出：3
```

**示例 3：**

```
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式
- '+' 不能用作一元运算(例如， "+1" 和 `"+(2 + 3)"` 无效)
- '-' 可以用作一元运算(即 "-1" 和 `"-(2 + 3)"` 是有效的)
- 输入中不存在两个连续的操作符
- 每个数字和运行的计算将适合于一个有符号的 32位 整数



## 题目分析

使用栈保存计算结果



## 题目解答

C++代码

```c++
class Solution {
public:
    int calculate(string s) {
        // 使用栈来储存字符串表达式中的数字
        stack<int> stk;
        // 为了方便计算，所有的操作都视为加法操作 那么原先的减法操作就相当于是加一个负数
        // 默认都是正数
        int sign = 1;
        // 保存计算的结果
        int res = 0;

        int len = s.length();
        for (int i = 0; i < len; i++)
        {
            // 获取此时的字符
            char ch = s[i];

            // 如果当前字符是数字的话
            if (ch >= '0' && ch <= '9')
            {
                // 那么可以通过 - '0' 这个操作把字符转换为整数
                // 相当于转换成了 ascii 码进行的数字运算
                long value = ch - '0';

                // 去查看当前字符的后一位是否存在 如果后一位依旧是数字，那么就需要把后面的数字累加上来
                while (i + 1 < len && s[i + 1]>= '0' && s[i + 1] <= '9')
                {
                    i++;
                    value = value * 10 + s[i] - '0';
                }
                // 那么把获取到的数累加到结果 res 上
                res = res + sign * value;
            }
            else if (ch == '+')
            {
                sign = 1;
            }
            else if (ch == '-')
            {
                sign = -1;
            }            
            else if (ch == '(')
            {
                // 先把 ( 之前的结果存放到栈中
                stk.push(res);
                // 重新初始化 res 为 0
                res = 0;
                // 把 ( 左边的操作符号存放到栈中
                stk.push(sign);
                sign = 1;
            }
            else if (ch == ')')
            {
                // 先获取栈顶元素，即左括号外面的符号
                int fromsign = stk.top();
                // 把栈顶元素弹出
                stk.pop();
                // 再获取栈顶元素，即左括号结果
                int fromres = stk.top();
                // 把栈顶元素弹出
                stk.pop();
                // 那结果就是括号外面的结果 + 括号里面的结果，至于是加正数还是负数，取决于左括号外面的符号
                res = fromres + fromsign * res;
            }                 
        }
        return res; 
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(*n*)，其中 n 为字符串 s 的长度。需要遍历字符串 s 一次，计算表达式的值。
* 空间复杂度：*O*(*n*)，其中 n 为字符串 s 的长度。空间复杂度主要取决于栈的空间，栈中的元素数量不超过 n。

