# 560.和为 K 的子数组

## 题目描述 

https://leetcode.cn/problems/subarray-sum-equals-k/

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的连续子数组的个数 。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`



## 题目分析

> **前缀和**：前缀和指一个数组的某下标之前的所有数组元素的和（包含其自身）。
>
> 利用前缀和这种特点，可以快速的计算某个区间内的和，比如前 i 个元素的前缀和为 `preSum[i] = num[0] + nums[1] + ... + nums[i]` ，而前 j 个元素的前缀和为 `preSum[j] = num[0] + nums[1] + ... + nums[j]` 。
>
> 那么区间 **[ i  , j ]** 之间的**子数组之和**就是 **preSum[j] - preSum[i]**

基于这种思路，可以先遍历一次数组，求出前缀和数组。

题目这个时候就变成了**需要寻找出多少个 i 和 j 的组合，使得 [ i , j ] 这个区间的和为 k**。

在计算过程中，有两个 for 循环发生了嵌套，时间复杂度来到了 O(n^2) 级别。

**需要优化**。

事实上，我们不需要去计算出**具体**是哪两项的前缀和之差等于k，只需要知道**等于 k 的前缀和之差出现的次数 count**，所以我们可以在遍历数组过程中，先去计算以 nums[i] 结尾的前缀和 pre，然后再去判断之前有没有存储 pre - k 这种前缀和，如果有，那么 pre - k 到 pre 这中间的元素和就是 k 了。

具体操作如下：

1、利用哈希表，以前缀和为键，出现次数为对应的值，记录 pre[i] 出现的次数。

2、开始从头到尾遍历 nums 数组，在遍历过程中，会执行两个操作。

3、存储索引为 i 的这个元素时，前缀和的值是多少，并且把这个值出现的频次存储到 mp 中。

4、判断之前有没有存储 pre - k 这种前缀和，如果有，说明 pre - k 到 pre 直接的那些元素值之和就是 k。

5、返回结果。



## 题目解答

C++代码

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // 统计和为 K 的子数组的数量
        int count = 0;
        
        // 记录遍历到索引为 i 的这个元素时，前缀和的值是多少
        int pre = 0;

        // 利用哈希表，以前缀和为键，出现次数为对应的值，记录 pre[i] 出现的次数 
        unordered_map<int, int> mp;

        // 一开始，需要设置前缀和为 0 时，出现的次数为 1 次
        // 这一行的作用就是为了应对 nums[0] +nums[1] + ... + nums[i] == k 这种情况
        mp[0] = 1;

        for(int i = 0; i < nums.size(); i++){
            // 存储索引为 i 的这个元素时，前缀和的值是多少
            pre += nums[i];

            // 判断之前有没有存储 pre - k 这种前缀和
            if(mp.find(pre - k) != mp.end()){
                // 如果有，说明 pre - k 到 pre 直接的那些元素值之和就是 k
                // 找到了一组，累加到 count 上                
                count += mp[pre-k];
            }
            // 这个值出现的频次存储到 mp 中
            mp[pre]++;
        }

        return count;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：O(n)，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。
* 空间复杂度：O(n)，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。

