# 30.串联所有单词的子串

## 题目描述 

https://leetcode.cn/problems/substring-with-concatenation-of-all-words

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联字串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

**示例 1：**

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**示例 2：**

```
输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
```

**示例 3：**

```
输入：s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。
```

**提示：**

- `1 <= s.length <= 104`

- `1 <= words.length <= 5000`

- `1 <= words[i].length <= 30`

- `words[i]` 和 `s` 由小写英文字母组成

  

## 题目分析

初始化一个哈希表，用来统计字符串数组中每个字符串出现的频率

滑动窗口，查找是否包含字符串数组中所有字符串

## 题目解答

C++代码

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        // 字符串s的长度
        int len = s.size();

        // 字符串数组里面单词总个数
        int wordNum = words.size();

        // 由于 words 中所有字符串长度相同
        // 通过题目的提示，words.length >= 1 ，所以每个单词长度都和 words[0] 一样
        int wordLen = words[0].size();

        // words 总长度，可以理解为这个字符串数组拼接为一个大的字符串的长度
        int totalLen = wordNum * wordLen;

        // 存储 words 的单词和个数
        unordered_map<string, int> allWords;
        for(string str: words){
            allWords[str]++;
        }
        // 在滑动窗口中寻找符合要求的单词
        for(int i = 0; i < wordLen; i++){
            // 当前窗口范围为 [ left , right ) ，左闭右开
            int left = i;
            int right = i;
            int count = 0;

            // 存储 [ left, right ） 内符合条件的单词及其数量
            unordered_map<string, int> hasWords;
            while(right + wordLen <= len){
                string cur = s.substr(right, wordLen);

                // 滑动窗口的右端的位置得到更新
                right += wordLen;

                // 查看字符串数组 words 当中是否存在这个 cur 单词
                // 即在哈希表 allWords 查看  如果存在，代表此时加入到滑动窗口的元素是一个需要的合法单词
                if(allWords.count(cur)){
                    // 更新数量
                    hasWords[cur]++;
                    // 有效单词数+1
                    count++;

                    // 特殊情况：
                    // 虽然 allWords 存在 cur，但  [ left, right ] 区间中 cur 的个数太多了，次数超了
                    // 需要一直舍弃左边的直至合法
                    while(hasWords[cur] > allWords[cur]){
                        // 每个单词的长度为 wordLen，因此 [ left , left + wordLen ） 为一个单词
                        string del = s.substr(left, wordLen);
                        // 执行删除操作
                        hasWords[del]--;
                        // 滑动窗口的左端移动
                        left += wordLen;
                        // 有效单词数 -1
                        count--;
                    }
                }else{
                    // 如果不存在 说明此时加入到滑动窗口的元素 cur 是不合法
                    left = right;
                    hasWords.clear();
                    count = 0;
                }

                // 在每一个滑动窗口里面，都会判断一下里面是否恰好包含了所有的有效单词
                if(count == wordNum) res.push_back(left);
            }
        }

        return res;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。
* 空间复杂度：*O*(m*×*n)，其中 m 是 words 的单词数，n 是 words 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次。

