# 287.寻找重复数

## 题目描述 

https://leetcode.cn/problems/find-the-duplicate-number/

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

 

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

 

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？



## 题目分析

> 抽屉原理：如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。

最直观的想法就是使用哈希表，但题目要求只能用常量级 O(1) 的额外空间，于是哈希表的思路走不通。

### 方法一：二分查找

我们定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，假设我们重复的数是 target，那么 [1,target−1]里的所有数满足 cnt[i]≤i，[target,n] 里的所有数满足 cnt[i]>i，具有单调性。

以示例1为例，我们列出每个数字的cnt值：

| nums | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| cnt  | 1    | 3    | 4    | 5    |

示例中重复的整数是 2，我们可以看到 [1,1] 中的数满足 cnt[i]≤i，[2,4] 中的数满足 cnt[i]>i 。

如果知道cnt[]数组随数字i逐渐增大具有单调性(即target前cnt[i] ≤ i，target后cnt[i] > i)，那么我们就可以直接利用二分查找来找到重复的数。



### 方法二：二进制

我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。

考虑到第 i 位，我们记 nums 数组中二进制展开后第 i 位为 1 的数有 x 个，数字 [1,n] 这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 x>y。

仍然以示例 1 为例，如下的表格列出了每个数字二进制下每一位是 1 还是 0 以及对应位的 x 和 y 是多少：
那么按之前说的我们发现只有第 1 位 x>y ，所以按位还原后 $target=(010)_2=(2)_{10}$，符合答案。

|       | 1    | 3    | 4    | 2    | 2    | x    | y    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第0位 | 1    | 1    | 0    | 0    | 0    | 2    | 2    |
| 第1位 | 0    | 1    | 0    | 1    | 1    | 3    | 2    |
| 第2位 | 0    | 0    | 1    | 0    | 0    | 1    | 1    |



### 方法三：快慢指针

我们对 nums 数组建图，每个位置 i 连一条 i→nums[i] 的边。由于存在的重复的数字 target，因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口，那么整个问题就等价于[142.环形链表](../0142.环形链表II/0142.环形链表II.md)

我们先设置慢指针 slow 和快指针 fast，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。



## 题目解答

C++代码

**方法一：二分查找**

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size();
        int left = 1, right = n - 1, ans = -1;
        while(left <= right){
            int mid = (left + right) >> 1;

            int cnt = 0;
            for(int i = 0; i < n; i++){
                cnt += nums[i] <= mid;
            }

            if(cnt <= mid){
                left = mid + 1;
            }
            else{
                right = mid - 1;
                ans = mid;
            }
        }
        return ans;
    }
};
```

复杂度分析：

* 时间复杂度：O(nlogn)。其中 n 为 nums 数组的长度。二分查找最多需要二分 O(log⁡n) 次，每次判断的时候需要O(n) 遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 O(nlog⁡n)
* 空间复杂度：O(1)。我们只需要常数空间存放若干变量。

**方法二：二进制**

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        // 确定二进制下最高位是多少
        int bit_max = 31;
        while(!((n-1)>>bit_max)){
            bit_max -= 1;
        }

        for(int bit = 0; bit <= bit_max; ++bit){
            int x = 0, y = 0;
            for(int i = 0; i < n; ++i){
                if(nums[i] & (1 << bit)){
                    x += 1;
                }
                if(i >= 1 && (i &(1 << bit))){
                    y += 1;
                }
            }
            if(x > y){
                ans |= 1 << bit;
            }
        }
        return ans;
    }
};
```

复杂度分析：

* 时间复杂度：O(nlog⁡n)，其中 n 为 nums 数组的长度。O(log⁡n) 代表了我们枚举二进制数的位数个数，枚举第 i 位的时候需要遍历数组统计 x 和 y 的答案，因此总时间复杂度为 O(nlog⁡n)。

* 空间复杂度：O(1)。我们只需要常数空间存放若干变量。

**方法三：快慢指针**

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            // 慢指针每次只会向前移动 1 步
            slow = nums[slow];
            // 快指针每次只会向前移动 2 步
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        //返回相遇的节点位置就是环形入口节点位置
        return slow;
    }
};
```

复杂度分析：

* 时间复杂度：O(n)。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。
* 空间复杂度：O(1)。我们只需要常数空间存放若干变量。
