# 409.最长回文串

## 题目描述 

https://leetcode.cn/problems/longest-palindrome

给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。

在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。

 

**示例 1:**

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**示例 2:**

```
输入:s = "a"
输出:1
```

**示例 3：**

```
输入:s = "aaaaaccc"
输出:7
```

 

**提示:**

- `1 <= s.length <= 2000`
- `s` 只由小写 **和/或** 大写英文字母组成



## 题目分析

回文串是一个正着读和反着读都一样的字符串。我们可以发现，在一个回文串中，只有最多一个字符出现了奇数次，其余的字符都出现偶数次。

那么我们如何通过给定的字符构造一个回文串呢？我们可以将每个字符使用偶数次，使得它们根据回文中心对称。在这之后，如果有剩余的字符，我们可以再取出一个，作为回文中心。

1. 统计每个字母出现的频次

2. 根据奇偶性来判断当前字母的使用次数为多少

## 题目解答

C++代码

```c++
class Solution {
public:
    int longestPalindrome(string s) {
        vector<int> count(58, 0);

        // 统计每个字母出现的频次
        for(char c : s){
            count[c - 'A']++;
        }

        int ans = 0;
        for(int x : count){
            // 根据奇偶性来判断当前字母的使用次数为多少   
            ans += x / 2 * 2;
            
            // 也可以通过按位与：& 判断 x 的奇偶性
            //ans += x - (x & 1);
            
            //在发现了第一个出现次数为奇数的字符后，我们将 ans 增加 1，
            //这样 ans 变为奇数，在后面发现其它出现奇数次的字符时，我们就不改变 ans 的值了。
            if(x % 2 == 1 && ans % 2 == 0){
                ++ans;
            }
        }
        return ans;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(*N*)，其中 N 为字符串 `s` 的长度。我们需要遍历每个字符一次。
* 空间复杂度：*O*(*S*)，其中 S 为字符集大小。由于题目中保证了给定的字符串 `s` 只包含大小写字母，因此我们也可以使用哈希映射（HashMap）来存储每个字符出现的次数，

