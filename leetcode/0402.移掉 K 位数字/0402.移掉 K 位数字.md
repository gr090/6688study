# 402.移掉 K 位数字

## 题目描述 

https://leetcode.cn/problems/remove-k-digits

给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

 

**示例 1 ：**

```
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

**示例 2 ：**

```
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**示例 3 ：**

```
输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。
```

 

**提示：**

- `1 <= k <= num.length <= 10^5`
- `num` 仅由若干位数字（0 - 9）组成
- 除了 **0** 本身之外，`num` 不含任何前导零



## 题目分析

贪心 + 单调栈

对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小。基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。

基于上述分析，我们可以得出「删除一个数字」的贪心策略：

给定一个长度为 n 的数字序列 \[D0D1D2D3…Dn−1]，从左往右找到第一个位置 i（i>0）使得 Di<Di−1，并删去 Di−1；如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。

考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 k 个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。

因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到

* 栈为空
* 或者新的栈顶元素不大于当前数字
* 或者我们已经删除了 k 位数字

最终，从栈底到栈顶的答案序列即为最小数。

考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。

## 题目解答

C++代码

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        stack<char> s;

        string result = "";
        for(int i = 0; i < num.length(); i++){
            char digit = num[i];
            // 如果此时
            // 1、栈不为空
            // 2、栈顶元素大于此时遍历的字符
            // 3、还没有删除足够多的数字，即 k > 0
            // 那么这个时候需要把栈顶元素弹出
            while(!s.empty() && s.top() > digit && k > 0){
                s.pop();
                k--;
            }
            
            // 如果发现此时遍历的字符为 0 并且栈为空
            // 那么就不要把 0 放入到栈中，否则最终的结果会以 0 开头
            if(digit == '0' && s.empty()){
                continue;
            }
            
            // 把符合要求的字符放入到栈中
            s.push(digit);
        }
		// 遍历完所有的字符后，如果发现还没有删除足够多的元素，那么需要继续删除
        while(!s.empty() && k > 0){
            s.pop();
            k--;
        }
        if(s.empty()) return "0";

        while(!s.empty()){
            // 那么从栈顶到栈底把字符添加到 result 上
            result += s.top();
            s.pop();
        }
        // 由于 s 中的栈底是数字的最高位，栈顶是最低位
        // 所以此时 result 保存的顺序是最低位到最高位
        // 需要执行一次翻转操作
        reverse(result.begin(), result.end());
        return result;
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：*O*(*n*)，其中 n 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k 次。
* 空间复杂度：*O*(*n*)。栈存储数字需要线性的空间。

