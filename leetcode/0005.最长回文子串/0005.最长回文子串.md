# 5.最长回文子串

## 题目描述 

https://leetcode.cn/problems/longest-palindromic-substring

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成



## 题目分析

动态规划

对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。

根据这样的思路，我们就可以用动态规划的方法解决本题。

dp\[i][j]表示字符串 s 第 i 个字符和字符串 s 第 j 个字符之间的子串是否是回文子串

* i == j，重合，只有一个字符的字串显然是回文子串。dp\[i][j] = true
* i != j ，判断 i 和 j 所指向的字符是否相等
  * s[i] != s[j]，dp\[i][j] = false
  * s[i] == s[j]，则dp\[i][j]取决于dp\[i+1][j-1]

动态规划的状态转移方程：
$$
dp(i,j)=dp(i+1, j-1)  (S_i == S_j)
$$
也就是说，只有 s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j] 才会是回文串。

上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。

最终的答案即为所有 dp(i,j)=true 中 j−i+1（即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。



## 题目解答

C++代码

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length();
        // 设置数组 dp，用来存储字符串 s 的 [i,j] 区间的子串是否是回文子串
        auto dp = vector<vector<bool>> (len ,vector<bool>(len));

        // dp[i][i]，这个区间的字符只有一个，肯定是回文子串
        for(int i = 0; i < len; i++){
            dp[i][i] = true;
        }

        // 设置变量记录最长的回文子串的长度
        int maxLen = 1;
        // 设置变量记录最长的回文子串的开始位置，从后向前寻找
        int begin = len -1;

        // i 从字符串 s 的【尾部】开始向前遍历，j 从 i + 1 开始向后遍历
        // 不断的逼近二维数组最右上角的位置，即求 dp[0][length - 1]
        for (int i = len - 1; i >= 0; i--) {
           for( int j = i + 1; j < len; j++ ){
                if(s[i] == s[j]){
                    // 如果 [i , j] 这个区间中只有 2 个字符，并且此时两个字符还是一样的
                    // 那么肯定是回文子串
                    if(j - i + 1 == 2){
                        dp[i][j] = true;
                    }else{
                        // 否则，当前这个区间是否是回文子串区间取决于 [ i + 1 , j - 1 ] 这个区间
                        dp[i][j] = dp[i+1][j-1];
                    }   
                }
                else{
                    dp[i][j] = false;
                }

                if(dp[i][j] && j - i + 1 > maxLen){
                    maxLen = j - i + 1;
                    begin = i;
                }
           }
        }

        return s.substr(begin, maxLen);
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：O(n^2^)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2^)，对于每个状态，我们需要转移的时间为 O(1)。
* 空间复杂度：*O*(n^2^)，即存储动态规划状态需要的空间。

