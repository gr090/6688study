# 343.整数拆分

## 题目描述 

https://leetcode.cn/problems/integer-break

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`



## 题目分析

动态规划

对于正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 x 是拆分出的第一个正整数，则剩下的部分是 n−x，n−x 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

dp[i]表示正整数 i 拆分之后结果的最大乘积

当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：

* 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；

* 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。

状态转移方程：
$$
dp[i]=max_{1≤j<i}\{max(j*(i-j),j*dp[i-j])\}
$$
需要遍历所有的 j 得到 dp[i] 的最大值。

## 题目解答

C++代码

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        dp[2]=1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j < i-1; j++){
                dp[i] = max(dp[i], max(dp[i-j] * j, (i-j)*j));
            }
        }

        return dp[n];
    }
};
```

TypeScript代码

```typescript

```

复杂度分析：

* 时间复杂度：O(n^2)，其中 n 是给定的正整数。对于从 2 到 n 的每一个整数都要计算对应的 dp 值，计算一个整数对应的 dp 值需要 O(n) 的时间复杂度，因此总时间复杂度是 O(n^2)。
* 空间复杂度：O(n)，其中 n 是给定的正整数。创建一个数组 dp，其长度为 n+1

